### 배경지식

#### 교착상태(deadlock)

---

![](https://velog.velcdn.com/images/sujipark2009/post/b8dc4dbc-6c27-490c-a9b8-b0adb8fd2f72/image.png)

어떠한 차도 움직일 수 없는, 된 상태이다.

더이상 진행이 불가능한 상태.

시스템안에 자원이 있는데, 프로세스들 각각이 자원을 가지고 있으면서 다른 프로세스의 자원을 기다리는 상황이다.

![](https://velog.velcdn.com/images/sujipark2009/post/9467c09c-acd7-4e14-b9ca-df569d604817/image.png)

P0는 자원 A를 가진 상태에서 CPU를 뺏기고, P1은 B를 가지고 CPU를 뺏긴 상황이라 해보자.

이렇게되면 2개의 프로세스는 A와 B라는 Binary Semaphore를 얻어서 작업을 하고싶은 상황인데, 하나로는 작업을 못하고 서로가 가진 다른 자원을 기다리게 되는 상황이 된다.

한 Tape Drive에서 다른 Tape Drive로 복사를 하고싶은 상황이 한 예시가 될 수 있다.

deadlock은 **자원의 동시충족**을 못할 때 발생한다.

자기가 가진 자원을 절대 내놓지 않으면서, 다른 자원을 얻으려고 할 때 발생한다.

#### Deadlock 발생의 4가지 조건

---

**Mutual Exclusion**

- 상호 배타적으로 쓰는 그런 자원인 경우만 생길 수 있다는 것.

만약 A가 쓰는 도중에 B도 동시에 쓸 수 있다면 그런 상황이 생기지 않을 것이다.

**No Preemption**

- 비선점

자원을 빼앗을 수 있으면 데드락이 생기지 않는다.

**Hold and Wait**

- 자원이 1개만 필요하면 데드락이 생길 일이 없다.

내가 가진 자원은 내려놓지 않고, 다른 자원을 얻으려고 할 때.

뭔가 일을 하기위해 2개의 자원이 필요한데 1개는 얻은 상황이고 나머지 1개가 필요할 때,
가진 자원을 절대 내려놓지 않고 다른 1개의 자원을 기다리는 것.

**Circular Wait**

- 필요한 자원들끼리 사이클을 형성하는 상황이 되어야 발생

데드락이 생기려면 위의 4가지 조건을 모두 만족해야 생기고, 어느 한가지라도 만족하지 않으면 생기지 않는다.

#### Resource-Allocation Graph(자원 할당 그래프)

---

![](https://velog.velcdn.com/images/sujipark2009/post/290c7bf3-1d11-41bd-a0c8-47e43aeb987d/image.png)

프로세스가 N개, 자원이 M개 있는 상황을 표현한 것이다.

자원(R) -> 프로세스(P) 이 화살표는 이 자원을 이 프로세스가 점유하고 있다는 의미이다.

반대로 프로세스(P) -> 자원(R) 이 화살표는 프로세스가 자원을 기다리고 있다는 의미이다.

자원안에 점이 여러개 있는것은, 자원의 인스턴스가 여러 개 라는 의미이다.

1번 자원은 2번 프로세스가 가지고있고 그러면서 3번 자원을 기다리고 있다.

3번자원은 3번 프로세스가 가지고 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/1b509dd4-e19d-4ea3-8522-ce6ac8daa989/image.png)

이 그래프를 보고, 데드락이 생겼는지 아닌지 파악할 수 있다.

왼쪽 그래프는 데드락이 생겼다!

화살표를 따라가면서 사이클이 생기면 데드락인데, 사이클이 2개가 만들어져서 데드락이 생긴다.

오른쪽은 사이클이 있긴 하지만, 데드락이 아니다.

사이클과 무관하게 P2,P4가 자원을 가지고 있고, P4가 자원을 반납하면 P3은 자원을 받을 수 있고 마찬가지로 P2가 자원을 반납하면 P1이 얻을 수 있다.

#### Deadlock의 처리 방법

---

![](https://velog.velcdn.com/images/sujipark2009/post/e2b272d3-8be8-4f29-a339-9d868587af96/image.png)

앞에서는 데드락의 조건(상호배제,비선점,점유대기,순환대기)를 봤고

이제 어떻게 데드락을 처리해야하는지 보자.

왜 **방지**가 아닌 **처리**라고 하냐면, 위의 2가지 방법은 방지이지만, 아래 2가지 방법은 데드락이 발생해도 그냥 두기 때문이다.

#### Deadlock Prevention

---

![](https://velog.velcdn.com/images/sujipark2009/post/18b51159-3e99-488a-9275-91f8acc24f24/image.png)

아까 데드락의 조건 4가지 중 하나를 무산시켜서 막는 방법이다.

**Mutual Exclusion**

사실, 공유되는 자원이라면 애초에 데드락이 걸릴 일이 없으므로, 이걸 무산시키는 건 의미가 없다.

**Hold and Wait**

내가 가진 자원은 절대 내어놓지 않으면서 내가 충족못한 자원을 기다리는 방식 때문에 데드락이 생겼었다.

만약 기다리는 상황이 생기는 경우, 내가 가진 자원을 모두 내어놓게 되면 데드락이 발생하지 않는다는 것이다.

만약 작업을 위해 3개의 자원이 필요하다면, 3개를 다 얻을 수 있는경우만 자원을 할당받도록 하는 것이다.

근데 이렇게 하면 자원이 너무 낭비가 될 것이다.
자원을 항상 쓰는게 아니라, 어느 순간에 쓸 텐데 자원을 모두 다 가지고 시작하는건 낭비이다.

자원이 필요할 경우 보유 자원을 모두 내어놓고 다시 요청해야한다.

**No Preemption**

비선점을 없앤다는 말은, 빼앗기도록 하면 된다는 의미이다.

근데 자원중에서는 빼앗을 수 있는 자원이 있고 그렇지 않은게 있는데 CPU와 Memory는 뺏을 수 있는 자원이다.

CPU는 왜 뺏어도 괜찮냐면, CPU는 뺏기기 전에 context를 저장하고 새로운 context를 load하는 식으로 설계가 되었기 때문이다.

그런데, 이게 안되는 자원들이 있어서 이런 방식을 사용할 수 있는 자원이 너무 한정되어 있기때문에 항상 사용할 수 있는 방법은 아니다.

**Circular Wait**

사이클이 생기지 않도록 하려면 어떻게 해야하는가.

철학자 문제에서 살펴본 것처럼, 1번자원을 얻어야지만 2번자원을 얻을 수 있도록 자원에 할당 순서를 정해서 순서대로만 할당하면 된다.

높은 번호의 자원을 얻으려면 낮은 번호의 자원을 먼저 얻어야한다.
이런식으로 해버리면 데드락이 생기지 않는다.

근데 이러한 방법들은, 다 자원의 **사용률**을 저하시키고 **처리량**이 감소하는 방식들이다.

그래서 **Deadlock Prevention**은 데드락의 가능성을 원천봉쇄하지만, 다소 비효율적인 경향이 있다.

#### Deadlock Avoidance

---

![](https://velog.velcdn.com/images/sujipark2009/post/dcad6b03-2ef7-4879-8d87-d065f6369aa1/image.png)

추가적인 정보를 사용해서 데드락을 회피하는 것이다.

**프로세스마다 프로세스의 평생동안 자원을 최대로 쓰면 얼마나 쓰는지를 알고있다는 가정하에 그 정보를 이용해서 막는 것이다**

혹시 자원을 줬을 때 데드락의 위험이 있다면, 자원을 주지않는방식이다.

![](https://velog.velcdn.com/images/sujipark2009/post/94fcefce-dccc-48cc-809b-1332966d464f/image.png)

아까 이런 자원할당 그래프를 살펴봤었다.

아까는 실선만 있었는데, 지금보면 점선이 존재한다.
점선은, 항상 프로세스에서 자원으로 나가는 선만 존재한다.

이 선은, 이 프로세스가 해당 자원을 지금은 필요로하지 않지만 평생에 한 번 이상 요청할 수 있다는 것을 표현한 것이다.

P2가 실제로 자원을 요청하게 되면 점선이 실선으로 바뀐다.

지금 2번 자원은 아무에게도 할당되지 않았으므로, P2에게 할당이 된다.

점선을 포함해서 사이클이 형성되긴 했지만, 데드락이 발생한것은 아니다.

왜냐하면, P1이 일생동안 2번자원을 사용할 수 있다는 의미이지 현재 필요한건 아니기 때문이다.

**Deadlock avoidance**는 이런 점선까지 고려해서, "자원을 줘버리면 사이클이 생겨버린다!!" 는 것을 감지하고 자원을 안주고 그냥 놔두게 된다.

P1이 1번자원을 반납해서 P2가 가질 수 있을 때까지 할당해주지 않는다.

대단히 보수적으로, **자원을 주지않는 방식**으로 해결한다.

![](https://velog.velcdn.com/images/sujipark2009/post/a77921b2-a519-478d-ba85-d531f2ec2bf6/image.png)

**단일 인스턴스**인 경우, 자원 할당 그래프를 사용해서 점선을 포함한 사이클이 생기는 경우에 `unsafe` 상태가 되고 이는 데드락의 가능성이 있는 상태이기 때문에 아예 자원을 할당해주지 않는 방식을 사용하고

**다중 인스턴스**인 경우에는 `Banker's Algorithm` 을 사용한다.

#### Banker's Algorithm

---

![](https://velog.velcdn.com/images/sujipark2009/post/928c4407-fc42-4a18-9132-52345e0dc31f/image.png)

A,B,C 3종류의 자원이 있고 각각 10,5,7개의 인스턴스가 있는 상황이다.

그리고 각 프로세스에 현재 자원이 얼마나 할당되어있는지 나타나있다.

Available은 지금 할당되지 않고 남아있는 여분의 자원들이다.

그런데, Deadlock Avoidance에서는 각 프로세스들이 평생동안 최대로 쓸 자원을 미리 알고있다고 가정한다고 했다.

그게 바로 **Max**에 표시가 되어있는 것이다.

**Need**에는 현재 할당된 것을 제외하고, 추가로 요청할 수 있는 자원의 양이 표시되어있다.

이 상황에서 프로세스들이 자원을 추가 요청한다고 해보자.

P0가 C 하나를 요청하면, 이 자원을 줄 것인지 안 줄 것인지를 결정해야한다.

비록 자원에 여유가 있더라도, 자원을 줬을 때 **불안정한 상태**가 된다면 주지않는다.

P0에게 줬는데 만약 P0가 자원을 최대로 요청해버리면, 현재 가용 자원으로는 커버가 안되기 때문에 주지않는다.

P1의 요청은 1 2 2 만큼을 필요로 하고 이것은 현재 가용자원으로 커버할 수 있기 때문에, 이 프로세스에게는 최대의 자원을 할당해줄 수 있고 언젠가는 자원을 내려놓을 것이므로 **safe**로 판단하는 것이다.

P2는 A를 하나 요청한다해도, 줄 수는 있으나 받아들이지 않는다.
**가용자원만으로 최대 자원 요청을 처리할 수 있는 경우**만 받아들인다.

`safe`의 의미는, 가용자원만 가지고 프로세스를 하나씩 종료시킬 수 있는 **sequence**가 존재하는 경우를 의미한다.

<P1,P3,P4,P2,P0> 의 순서가 존재하므로 safe라고 할 수 있다.

안전한 친구들에게 자원을 몰아주고, 그것들이 종료되면 또 가용자원에 합쳐지고

이런식으로 하나씩 프로세스를 종료시켜 나가다 보면 모두에게 자원을 충족시킬 수 있는 sequence가 생기게 된다는 것이다.

근데 사실 Banker's Algorithm은 자원을 요청했을 때 줄 것인지 말 것인지를 결정하는 것이지 sequence를 찾아내는 건 아니다.

그래서 사실 간단하고 쉽다.

결론은 Banker's Algorithm을 사용하면 항상 safe한 상태가 되기 때문에 데드락에 걸리지 않는다는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/f5b668f1-24be-488f-b00a-f6883dd54ad9/image.png)

#### Deadlock Detection and Recovery

---

지금까지의 방법은 데드락이 안생기게 하는 방법이었는데, 지금부터는 데드락이 생기면 그냥 놔두는 방식이다.

데드락이 생기던 말던 여유자원이 있으면 그냥 주는 것이다.

만약 데드락이 생겨서 시스템이 느려지거나 특정 프로그램이 작동하지 않는 상황이 오면, **detection**하고 **recovery**하자는 것.

![](https://velog.velcdn.com/images/sujipark2009/post/35955fd2-756d-452d-8901-1faf9983fc0f/image.png)

이것도 자원당 인스턴스가 1개 있으면 그래프, 여러개면 Banker's Algorithm을 사용하면 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/5510af9c-5637-40e6-81dc-61811a9b34e5/image.png)

인스턴스가 1개있는 상황에서, 지금 왼쪽의 그래프에 데드락이 있는지 없는지를 파악해보자.

일단 사이클이 바로 존재한다는 것을 알 수 있고, 데드락이 있는 상황이다.

심지어 사이클이 한 개 더 있다.

이런 자원할당 그래프를 좀 더 간단하게 자원을 빼버리고 프로세스만 그린다면 두번째와 같다.

이걸 `wait-for` 그래프라고 한다.

만약, 자원당 인스턴스가 여러 개 있는 상황은?

![](https://velog.velcdn.com/images/sujipark2009/post/79aab722-af0a-4f78-bea8-b7aecda52b81/image.png)

Deadlock Detection에서는 여유자원이 있으면 그냥 준다고 했다.

지금 Request는 지금 실제 요청이 온 것인데, 가용자원이 없기 때문에 P1에게 자원을 줄 수 없는 상황이다.

P0,P2는 운이 좋다면 가진 자원을 내려놓을 수 있게 된다.

Deadlock detection과 Banker's를 비교해보면,

Banker's는 자원이 있어도 보수적으로 주는 방식이었고(미래까지 고려하는 방식)
detection 방식에서는 낙관적으로 생각해서 현재 가용자원이 있으면 그냥 바로 주는 것이다.

현재가 데드락인지 아닌지만 보는 것.

약간 그리디한 느낌이다.

만약 위 그림에서 P2가 C를 한개 더 요청한다고 하면, 자원을 할당해줄 수 있는 sequence가 없기 때문에 데드락이 생긴다.

이제 Detection을 했으면, Recovery를 해야한다.

![](https://velog.velcdn.com/images/sujipark2009/post/de79807c-f399-4b93-bcb7-afd6726f55fc/image.png)

2가지 방법이 있는데,

**Process Termination**

데드락에 연루된 프로세스들을 죽이는 방법

모든 프로세스를 줄이는 방식

- 하나씩 죽여서 데드락이 사라지는지를 확인하는 방법

**Resource Preemption**

자원을 빼앗는 방법

- 데드락에 연루된 프로세스를 하나 골라서 자원을 뺏어버리면 데드락이 없어지지 않을까?

- 희생될 프로세스를 정하는 방식은? -> 비용이 적게드는 프로세스

- starvation 발생가능 -> rollback 횟수 또한 고려해야한다.

#### Deadlock Ignorance

---

데드락은 굉장히 드물게 일어나기 때문에, 데드락에 대해서는 아무것도 하지 않겠다는 것.

현대의 운영체제는 대부분 이 방식을 채택하고 있다.

그럼 데드락은 왜 배울까?

데드락은 OS에서 고전적인 문제들 중 하나이고, 현대의 범용 OS는 데드락에 대해서 아무 일도 해주지 않는다.

그래서 사실 중요성이 조금 떨어지는 챕터긴하다.

데드락에 대해서 아무일도 하지 않으면, 데드락이 발생하면 어떻게 할까?

프로세스가 죽거나, 말을 안듣거나 하겠지? 그런 상황이 있으면 사람이 알아서 처리하게 된다..

### DeadLock에 대해 설명해주세요

---

- 일련의 프로세스가 자신의 자원을 점유하면서 다른 프로세스가 점유한 자원을 기다리면서 block된 상태

#### DeadLock에서 말하는 자원이란 어떤 것인가요?

---

- I/O Device, CPU Cycle, Memory space,Semaphore 등의 HW/SW자원을 모두 포함

#### DeadLock이 동작하기 위한 4가지 조건에 대해 설명해주세요

---

**Mutual Exclusion**

- 상호배제
- 한 번에 한 프로세스만이 자원을 사용할 수 있음

**No Preemption**

- 비선점
- 다른 프로세스에 의해 이미 점유 중인 자원을 강제로 뺴앗을 수 없음

**Hold and Wait**

- 점유 대기
- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 의해 점유된 자원을 추가로
  얻기 위해 대기하는 프로세스가 있음

**Circular Wait**

- 순환 대기
- 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 점유하고 있음

#### 3가지만 충족하면 왜 DeadLock이 발생하지 않을까요?

---

프로세스가 자원을 언젠가 얻을 수 있기 때문에 발생하지 않는다.

#### 교착 상태의 해결법은 무엇인가요?

---

**예방(Prevention)**

DeadLock의 4가지 필요조건 중 하나를 차단하여 DeadLock을 예방하는 방법

**상호배제**

- 자원은 한 번에 한 프로세스만이 사용하는것을 막을 수 없음

**점유 대기**

- 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 함

방법1 - 프로세스 시작 시 모든 필요한 자원을 할당받게 함

방법2 - 자원이 필요한 경우 보유 자원을 모두 내려놓고 다시 요청

**비선점**

- process가 어떤 자원을 기다려야 하는 경우, 이미 보유한 자원이 선점될 수 있도록 함

- 모든 필요한 자원을 얻을 수 있을 때 그 프로세스를 다시 시작

- state를 쉽게 save하고 restore할 수 있는 자원(CPU,Memory)

**순환대기**

- 모든 자원 유형에 우선 순위를 정하여 정해진 순서대로만 할당

- 순서가 3인 자원 R3을 보유 중인 프로세스가 순서가 1인 자원 R1을 할당받기 위해서는 우선 R3을 반납해야 한다.

**단점**

DeadLock을 원천적으로 막을 순 있지만 자원의 이용률, 전체 시스템의 성능, 기아 문제가 발생

**회피(Avoidance)**

- 자원 요청에 대한 부가적인 정보를 이용해서 DeadLock의 가능성이 없는 경우에만 자원을 할당 하거나 시스템 state가 원래 state로 돌아올 수 있는 경우에만 할당

- 자원 요청에 대한 부가적인 정보를 이용

자원 할당이 DeadLock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당

가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법

- Resource Allocation Graph Algorithm(각 자원에 하나의 instance만 있는 경우)

- Banker's Algorithm(각 자원에 두개 이상의 instance가 있는 경우)

**탐지 & 회복**

- DeadLock 발생은 허용하되 그에 대한 detection루틴을 두어 DeadLock 발견시 recover

- DeadLock 존재 여부는 Resource-Allocation Graph를 통해 알 수 있음

- recovery 방법

process termination - 연루된 모든 process를 죽이거나, Deadlock이 없어질 때 까지 하나씩 죽임

resource preemption - 비용이 가장 적은 process를 선정해 자원 회수

**무시(Ignorance)**

- 데드락이 거의 발생하지 않는다는 가정 하에 데드락에 대한 조치를 하지 않는 방법
- 실제로는 많은 시스템에서 사용되는 방법

- 데드락 처리에 대한 오버헤드를 줄임
- 데드락이 발생하면 시스템이 중단됨

#### Resource Allocation Graph Algorithm은 어떻게 동작하나요?

---

- 자원 할당 그래프

프로세스의 자원 할당 상태를 표현해주는 그래프

**과정**

Cycle이 존재하지 않으면 DeadLock이 아님

Cycle이 존재하면, 만약 자원당 하나의 인스턴스만 존재하면 데드락이지만 여러 인스턴스가 존재하면 데드락의 **가능성이 있음**

#### 데드락의 회피법 중 하나인 Banker's Algorithm에 대해 이야기해 보세요

---

- 다중 프로세스 환경에서 데드락을 방지하기 위해 사용하는 알고리즘

- 각 프로세스가 필요로 하는 자원의 최대값과 현재 할당된 자원의 양을 바탕으로 안정적인 상태(stable state)를 유지할 수 있는지 여부를 판단

**안정 상태(stable state)**

- 현재의 자원 할당 상태에서 모든 프로세스가 최대로 요구할 수 있는 자원을 충족시킬 수 있는 상태

**동작 과정**

- 자원 요청

프로세스가 자원을 요청하면, 시스템은 요청된 자원을 할당하기 전에 그 결과를 시뮬레이션

- 시뮬레이션

요청된 자원을 할당한 후의 상태에서, 모든 프로세스가 최대 요구 자원을 할당받을 수 있으면, 그 상태는 `안전 상태` 로 간주

- 자원 할당

시뮬레이션 후에 안전 상태가 유지될 것으로 판단되면, 실제로 자원을 프로세스에 할당

안전 상태를 유지할 수 없다면, 자원 요청을 보류

#### 은행원 알고리즘이 현실적으로 어려운 이유는 무엇인가요?

---

- 프로세스가 요구하는 최대 자원을 미리 알아야 함
- 사용가능한 모든 자원의 수를 알아야 함

#### 은행원 알고리즘의 단점은 무엇인가요?

---

- 모든 프로세스가 최대 자원을 요구할 때는 안정적인 상태를 유지할 수 없으므로 이러한 경우 데드락이 발생할 가능성이 있음

#### 왜 현대 OS는 DeadLock을 처리하지 않을까요?

---

- DeadLock은 빈번히 발생하는 이벤트가 아니다.

미연에 방지하기 위해 훨씬 더 많은 오버헤드가 발생

- 현대 시스템의 복잡성으로 인해 교착 상태를 완전히 방지하는 것은 불가능

- DeadLock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낌

사람이 직접 process를 죽이는 방법

#### 기아 상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요

---

- 다섯 명의 철학자들이 한 원탁에 앉아 젓가락을 사용하여 식사를 하는 상황

- 각 철학자들은 자신의 왼쪽과 오른쪽에 있는 두 개의 젓가락 중 하나만 사용

- 식사를 마치면 사용한 젓가락을 다시 테이블에 놓음

#### 철학자 문제에서 교착 상태의 성립 조건이 어떻게 될까요?

---

**점유 대기**

모든 철학자가 동시에 왼쪽 손에 젓가락을 들고 기다리며 오른손의 젓가락을 기다리는 경우 발생

#### 철학자 문제에서 경쟁 상태의 성립 조건은 어떻게 될까요?

---

여러 철학자들이 동시에 같은 젓가락을 잡으려고 시도할 때 발생

#### 철학자 문제의 해결책은 무엇일까요?

---

- 철학자들이 젓가락을 잡는 순서를 정함

한 번에 한 철학자만 젓가락을 잡을 수 있게 제한

**점유와 대기**

철학자가 한 번에 두 젓가락을 동시에 잡도록

**순환 대기**

홀수 번호의 철학자는 왼쪽 젓가락 먼저 / 짝수 번호의 철학자는 오른쪽 젓가락 먼저

이런식으로 잡게 하여 철학자가 반시계 방향으로 젓가락을 기다리는 순환 구조를 깨뜨림
