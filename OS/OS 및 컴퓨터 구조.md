### 컴퓨터의 구조를 설명해주세요

---

![](https://velog.velcdn.com/images/sujipark2009/post/fbe9415f-697c-49ab-8d75-98bb41547f4b/image.png)

**입출력장치**

- 입력 및 출력 장치

- Device Controller

**`Device Controller`** 란?

- 장치마다 존재하는 작은 CPU. 각 하드웨어 장치를 제어하는 역할
- 메모리 및 입출력 장치 등의 각 하드웨어 장치에 존재

**Device Controller 구성**

`Local Buffer` : 데이터를 임시로 저장하기 위한 작업 공간, 메인 CPU의 작업 공간인 메인 메모리와 비슷함

`Device Driver` : CPU가 실행하는 각 디바이스에 접근하기 위한 소프트웨어

**CPU**

접근범위 : 메인 메모리와 Local Buffer에 접근 가능

인터럽트 라인(Interrupt line) - CPU는 다음 기계어를 실행하기 전에 interrupt line의 interrupt 발생 여부 확인, 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 먼저 처리

레지스터(Register) - CPU 내부에 메모리보다 더 빠르면서 정보를 저장할 수 있는 작은 공간.
대표적으로 PC(Program Counter)가 있다(CPU가 처리할 다음 명령어의 메모리 주소를 가리키는 레지스터)

Mode bit - CPU에서 실행되는 것이 OS인지 사용자 프로그램인지 구분.

1인경우 사용자 모드

**저장장치**

메인 메모리 / 보조 기억 장치

#### 명령어는 어떻게 구성되어 있나요?

---

동작 코드(Op-Code) : 각 명령어의 실행 동작을 구분하여 표현
오퍼랜드(Operand) : 명령어의 실행에 필요한 자료나 실제 자료의 저장 위치

#### CPU가 명령어를 처리하는 과정을 말해주세요.

---

1. 읽기(Fetch Instruction) - 메모리에서 명령 가져오기

2. 해석(Decode Instruction) - 명령 해석하기

3. 실행(Execute Instruction) - 명령 수행하기

4. 기록(Write Back) - 수행 결과 기록하기

#### 명령어 처리 방식인 RISC와 CISC에 대해 설명해주세요

---

RISC(Reduced Instruction Set Computer)

- 명령어 세트를 단순화하여 명령어들을 조합하여 기능 수행
- 하나의 사이클로 명령어를 처리
- Load/Store 명령어마나 메모리에 대해 처리
- 복잡한 컴파일러 구조

CISC(Complex Instruction Set Computer)

- 하나의 기능에 대응하는 하나의 명령 존재
- 여러사이클로 명령어 처리
- 많은 명령어가 메모리를 참조하는 처리 방식
- 파이프라이닝 불가

#### DMA란 무엇인가요?

---

DMA(Direct Memory Access)

- 하드웨어이다.

- 입출력 장치와 메인 메모리 간에 데이터를 전송할 때 CPU의 개입 없이 직접 데이터를 전송하는 방식

**필요성**

- CPU의 작업을 멈추는 인터럽트를 줄이기 위해

- I/O 장치는 메모리에 직접 접근하지 못하고 CPU만 접근이 가능하다.
  입출력 장치에서 메모리로 데이터를 전송하려면 CPU가 중재해야 한다.

**동작**

- I/O장치가 작업을 끝내면 Local Buffer에 데이터를 저장한 후 인터럽트를 발생시킨다.

- 특정 분량이 찼을 때 DMA Controller가 CPU대신 I/O장치의 Local Buffer의 내용을 메모리에 COPY

- 한 번에 인터럽트를 걸어 인터럽트 빈도를 낮춤

**특징**

- 대용량 데이터를 전송해야 하는 고성능 시스템에서 매우 중요한 역할

**예시**

디스크와 같은 입출력 장치, 네트워크 카드, 사운드 카드 등에서 DMA방식

### 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.

---

프로그램이 작성된 소스 코드에서 실행 가능한 바이너리 형태로 변환되는 과정이다.

**컴파일**

소스코드(C++,JAVA 등)는 컴파일러에 의해 해당 언어의 기계어 형태인 목적 코드(Object code)로 변환

컴파일러가 코드의 구문 오류를 검사 + 필요한 경우 최적화 작업을 수행한다.

![](https://velog.velcdn.com/images/sujipark2009/post/a2fa03ab-c654-4591-8d4f-3f3a371ff3c3/image.png)

컴파일은 **원시 코드를 컴퓨터가 이해할 수 있는 언어로 번역해주는 과정**을 말한다.

1. Preprocessor

직역하면, 전처리기이다. C에서 #으로 시작하는 부분(#include,#define)을 소스코드로 변경해준다.

#include 같은 경우, 헤더파일에서 코드를 복사해주고 #define의 경우 정의한 값 또는 식으로 치환 및 적용시켜준다.

2. Compiler

컴파일러는 전처리기로 확장된 소스코드를 기계어에 근접한 **어셈블리어로 번역**해준다.
엄밀히 말해서 아직까지는 이진수로 번역된 상태는 아니다.

3. Assembler

어셈블리 언어를 **기계어로 번역**해준다. 이 단계에서 생성된 파일을 목적 파일(Object file)이라고 한다. **여기까지를 보통 컴파일이라고 칭한다**

4. Linker

여러 개의 Object file을 하나로 합치는 과정이다. 작성된 소스코드가 사용하는 OS API(System call) 또는 표준 라이브러리를 연결시켜 exe파일로 만든다.

**링킹**

컴파일 단계에서 생성된 목적 코드는 링커(linker)에 의해 하나의 실행 파일로 결합

링커 - 필요한 라이브러리와의 링크를 수행 / 각각의 목적 파일에서 정의된 함수와 변수의 참조를 해결

하나의 프로젝트에 여러 개의 소스코드 파일이 있으면 각 소스코드마다 목적 파일이 생성되고, Liner가 모든 목적 파일과 라이브러리를 종합해 하나의 실행 파일을 만드는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/2bd56e80-fae9-4a98-bef5-434859e4a949/image.png)

여기서 설명한 Linking 과정은 **정적 링킹(Static Linking)** 방법이다.

실행파일 안에 모든 내용이 다 들어있기 때문에, 별도의 라이브러리가 필요 없다. 따라서 실행시 속도가 빠르다는 장점이 있지만 잘 생각해보면 이는 **심각한 메모리 낭비**다.

수십명의 유저가 리눅스 서버에 동시에 접속해 정적 링킹으로 만들어진 실행 파일(이름만 출력하는)을 실행시키는 상황을 생각해보자.

그럼 실행파일 전체에 printf를 위한 라이브러리 코드가 다 들어가있다는 것이다. 50명이 이를 동시에 실행시키면 똑같은 printf 코드가 메모리에 50번 적재되는 것과 같다.

그래서 대안으로 등장한게 **동적 링킹(Dynamic Linking)** 방법이다.
많이 쓰이는 라이브러리 함수를 메모리에 한 번만 올리고, 프로그램이 라이브러리를 호출할 때 메모리에 있는 함수 주소로 점프해 실행한 후 다시 돌아오도록 하는 방법이다.

이러한 동적 링크 라이브러리를 윈도우에서는 **DLL(Dynamic Link Library)** 라 부르고 유닉스나 리눅스에서는 **Shared Library** 로 부른다.

그러나 동적 링킹은 점프 과정에서 약간의 오버헤드가 생기고 점프를 위한 불필요한 코드가 추가된다는 단점이 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/1fa125ed-9adc-4baf-8819-6cff0ddaadeb/image.png)

게임을 샀는데 게임의 라이브러리 일부분이 버전업된 경우를 생각해보면, 만약에 게임이 정적 링킹으로 만들어졌다면 버전업된 게임을 새로 구매해야 한다. 왜냐하면 실행 파일 안에 라이브러리 코드가 다 들어있기 때문이다. 하지만 게임이 동적 링킹으로 만들어졌다면 게임을 새로 사는것이 아니라 DLL만 업데이트 하면 된다.

왜냐하면 동적 링킹은 원래 코드와 라이브러리를 별도로 분리해놓기 때문에 라이브러리만 버전업시키면 그 성능을 그대로 받을 수 있다.

**로딩**

- 실행파일이 OS에 의해 메모리로 로드
- 동적 라이브러리가 필요한 경우, 로더(loader)는 해당 라이브러리를 메모리로 로드
- 실행 파일과 동적 라이브러리 간의 링크를 수행

로딩은 **데이터를 메모리로 옮기는 것**을 말한다.

컴파일이 완료된 프로그램을 실행시키면 .exe에 있는 파일이 메모리에 올라가게 되는데 이를 로딩이라고 한다.

**실행**

- 메모리로 로드된 프로그램이 CPU에 의해 실행
- 프로그램의 명령이 순차적 혹은 병렬적으로 실행
- 필요한 경우 OS의 서비스를 요청하는 시스템 콜을 수행

#### 프로그램이란 무엇인가요?

---

- 어떤 작업을 위해 실행할 수 있는 파일
- 특정 작업을 수행하는 일련의 명령어의 모음

#### 링커와 로더의 차이에 대해 설명해주세요

---

링커(Linker) -

- 여러 개의 오브젝트 파일(.o 또는 .obj파일)을 하나의 실행가능한 파일로 결합한다

오브젝트 파일은 컴파일러에 의해 생성되며 각각이 프로그램의 일부분을 포함

- 오브젝트 파일들 사이의 참조 결정

- 라이브러리

공유 라이브러리를 참조 / 정적 라이브러리를 포함시킴

- 결과물

실행 가능한 파일

로더(Loader) -

- 실행 가능한 파일을 메모리에 적재하여 실행 상태의 프로세스를 만듦

- 디스크에 있는 실행 가능한 파일을 메모리에 로드

- 필요한 메모리 영역을 할당

- 프로그램의 실행을 시작

프로그램이 실행되면 로더는 해당 프로그램의 메인 함수나 진입점(Entry Point)을 찾아 CPU가 실행을 시작

#### 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요

---

프로그램의 소스 코드를 실행하는 방식에서 차이가 있다.

`**컴파일 언어**`

- 컴파일 언어의 소스 코드는 컴파일러에 의해 기계어 코드로 번역되어 실행파일(exe등)을 생성

- 실행 파일은 해당 환경의 기계어로 작성되어, 실행 시 별도의 번역 과정 없이 바로 실행이 된다

**장점**

컴파일 과정은 한 번만 수행되므로, 실행 시간이 빠름

**단점**

플랫폼에 따라서 다시 컴파일 해야 함

**예시**

C,C++,Java(일부)

`**인터프리터 언어**`

- 인터프리터 언어의 소스 코드는 실행 시점에서 한 줄씩 해석되고 실행

- 별도의 실행 파일을 생성하지 않음

- 스크립트 언어라고도 부름

**장점**

플랫폼에 독립적, 소스 코드를 곧바로 실행할 수 있어 개발 과정이 단순

**단점**

실행 시간이 컴파일 언어보다 느리다

**예시**

Python,Ruby,Javascript

Java와 Python은 컴파일러와 인터프리터를 모두 사용한다.

- Java는 소스코드를 바이트코드로 컴파일하고, 이 바이트 코드를 JVM에서 인터프리트하여 실행

- Python도 소스 코드를 바이트코드로 컴파일한 뒤, 인터프리터가 이를 실행

#### JIT에 대해 설명해 주세요.

---

`Just-In-Time 컴파일`

- 프로그램 실행 도중에 실제 바이트 코드를 기계어로 변환하는 컴파일 기법
- 이는 프로그램 실행 시점에서(즉, Just-In-Time) 일어나므로, 이런 이름이 붙여졌다

`JIT 컴파일러`

- 동적 최적화
- 프로그램의 실행 패턴을 관찰하고 이를 바탕으로 최적화된 기계어 코드를 생성

예시 - 자주 사용되는 코드 경로를 인식하고 이를 특별히 최적화

사용 - 자바,파이썬,자바스크립트 등의 언어에서 주로 사용. 인터프리터와 함께 동작하여 프로그램의 실행 성능을 크게 향상

단점 - 컴파일 시간이 프로그램의 실행 시간에 포함된다.

- 프로그램의 시작 시점에서 약간의 지연

- JIT 컴파일러는 프로그램의 전체 실행 시간을 줄일 수 있으며, 이는 종종 초기 컴파일 시간에 대한 오버헤드를 상쇄한다.

#### 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.

---

1. 개발자가 자바 소스코드(.java)를 작성한다.

2. 자바 컴파일러가 자바 소스파일을 컴파일한다. 이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는, JVM이 이해할 수 있는 코드이다.

바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 Operand로 이루어져 있다.

3. 컴파일된 바이트 코드를 JVM의 클래스 로더(Class Loader)에게 전달한다.

4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올리게된다.

**클래스 로더 세부 동작**

- 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.

- 검증 : 자바 언어 명세(Java Language Specification)및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.

- 준비 : 클래스가 필요로 하는 메모리를 할당한다(필드,메서드,인터페이스 등)

- 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경

- 초기화 : 클래스 변수들을 적절한 값으로 초기화(static 필드)

5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다.

이때, 실행 엔진은 두가지 방식으로 변경한다.

- 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행속도가 느리다는 단점이 있다.

- JIT컴파일러 : 인터프리터의 단점을 보완하기위해 도입된 방식으로, 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고 바이너리 코드로 직접 실행하는 방식이다.

하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.

**JIT 컴파일러 세부**

JIT 컴파일러는, 자주 호출되는 메서드나 코드 블럭을 미리 기계어로 번역하여 캐싱을 해둔다.

그리고 이 자주 실행되는 부분을 `HotSpot` 이라고 한다.

JIT 컴파일은 런타임에 실행되는데, 보통 컴파일이라고 하면 컴파일 타임에 수행되는건데 왜 이건 런타임에 수행될까?

그전에 컴파일방식와 인터프리터 방식의 장단점을 알아보자.

**컴파일 방식의 단점**

컴파일 방식의 단점은, 시작 시간이 오래걸린다는 것이다.프로그램의 성능은 좋아지겠지만 시작 시간이 너무 오래걸린다.

실행을 하려면 컴파일 과정을 거쳐야 한다. 개발자가 코드를 한 줄만 수정해도 다시 컴파일을 해야 하기 때문에 프로그램이 시작 시간이 느리다는 단점이 있다.

(Java코드를 한줄만 수정해도 다시 컴파일 해야하는데?? 하지만 Java 코드를 바이트 코드로 컴파일하는 것은 아주 빠르게 수행된다고 한다. 또한 자바 컴파일러는 수정된 부분의 코드만 다시 컴파일을 하고 기존 코드는 재사용하기 때문에 일반적인 컴파일보다 빠르다고 함)

**컴파일 방식의 장점**

컴파일을 한 번만 하고 실행을 많이 한다면 컴파일 방식이 유리할 것이다.

한번만 컴파일을 해놓으면 해당 프로그램은 실행 시간중에 기계어로 번역하는 작업을 하지 않고 이미 번역되어 있는 기계어를 바로 실행하기 때문에, 컴파일을 할 때는 오래 걸려서 답답할 수도 있겠지만 사용자는 아주 빠른 성능의 프로그램을 사용할 수 있다.

즉, 컴파일 방식의 장점은 실행 속도가 빠르다는 것이다.

**인터프리터 방식은?**

인터프리터 방식은 실행하기 전에 전체 코드를 기계어로 번역하는 작업(컴파일)을 하지 않아도 되므로 시작 시간은 컴파일 방식에 비해서 빠르다. 하지만 실행 중에 코드를 기계어로 번역하는 작업을 해야 하기 때문에 실행 속도는 컴파일 방식보다 느릴 것이다.

만약 A라는 메서드가 1번 호출될 때 다음과 같다고 해보자

![](https://velog.velcdn.com/images/sujipark2009/post/8cc1b857-fe0f-48dd-a122-4c7b3880b7af/image.png)

A가 1000번 호출된다면?

![](https://velog.velcdn.com/images/sujipark2009/post/97b9676f-c052-4617-8e82-0c8fbad5e6a5/image.png)

실행 중에 인터프리터 방식으로 해석을 하면 해당 코드를 기계어로 해석하는 똑같은 작업을 1000번 하는 것이다.

따라서 컴파일 방식은 1001초, 인터프리터 방식은 2000초가 걸린다.
그리고 이 차이는 A 메서드가 많이 호출될수록 점점 커질 것이다.

따라서 자주 실행되는 코드를 **미리 기계어로 컴파일 해두면** 실행시간을 훨씬 줄일 수 있을 것이다.

**그래서 JIT 컴파일러가 런타임에 동작하는 이유는?**

이러한 단점을 극복하기 위해서 Java 1.3 HotSpot VM부터 JIT 컴파일러를 도입하여 자주 실행되는 메소드는 실행중에 기계어로 번역을 하는 방법을 채택한다.

이 방법으로, 시작시간은 여전히 빠르면서 실행 중에 자주 실행되는 코드를 기계어로 번역을 하여 인터프리터 방식의 실행 속도가 느리다는 단점을 어느정도 극복할 수 있다.

JIT 컴파일러가 런타임에 실행됨으로써 얻을 수 있는 장점을 살펴보자.

```
for (int i = 0; i < 1000; i++) {
	// 코드 생략
}
```

위의 반복문을 보면 1000번 실행될 것이라는 것을 컴파일 시점에 알 수 있다.

```
int count = scanner.nextInt(); // 사용자의 입력을 받음
for (int i = 0; i < count; i++) {
	// 코드 생략
}
```

하지만 이 코드는 반복문이 몇 번 실행될지 예측을 할 수 없는데, 사용자의 입력값에 따라 반복문의 실행 횟수가 달라지기 때문이다.

또한 서버 애플리케이션의 경우, 클라이언트가 어떤 API를 많이 호출하는지에 따라 특정 메서드의 실행 횟수가 달라지기에, 컴파일 시점에 더욱 더 예측을 하기가 어렵다.

하지만 런타임에는 이러한 정보들을 알 수 있다.

이렇게 런타임에 컴파일을 하게 되면, **동적 최적화**를 할 수 있다.
컴파일 타임에는 알 수 없었던 정보들을 알 수 있기 때문에 프로그램의 실행 패턴 등 더 많은 정보를 기반으로 최적화를 할 수 있다는 장점이 있다.

따라서 자주 실행되는 코드를 미리 기계어로 컴파일 해두면 실행시간을 훨씬 줄일 수 있을 것이다.

하지만, **이 메소드가 자주 호출되는지 어떻게 알까?**

여기서 JIT 컴파일러가 런타임에 수행됨으로써 얻을 수 있는 장점이 드러난다.

메서드가 몇 번 호출되어야 JIT컴파일러가 컴파일을 할 지 그 임계값은 -XX:CompileThreshold 옵션으로 지정할 수 있다.

만약 Test.class라는 클래스파일을 실행시킬 때, 메서드가 5000번 이상 호출되었을 때 JIT 컴파일을하고 싶다면

java -XX:CompileThreshold=5000 Test

이렇게 해주면 된다.

Java 8 이상의 HotSpot JVM에서 CompileThreshold 옵션의 기본값은 10,000이다.

하지만 컴파일을 런타임에 하기 때문에 JIT 컴파일러가 컴파일을 하는 동안에는 응답시간이 지연될 수도 있다. 따라서 컴파일을 빠르게 하는 것도 중요하다.

최적화를 잘 하면 컴파일 후의 코드는 성능이 매우 좋아지겠지만,, 컴파일 시간이 오래 걸리게 된다.
최적화를 엄청 잘 하지 않으면 컴파일 시간은 덜 걸려서 실행 중에 지연 시간은 덜 발생하겠지만, 컴파일 후의 코드가 성능이 그렇게 좋아지지는 않을 것이다.

지연시간도 줄이고 최적호도 잘하면 매우 좋겠지만, 하나를 개선하려면 하나를 포기해야한다.

JVM은 두 가지 장점을 최대한 살릴 수 있도록 `Tiered` 컴파일이라는 방식을 채택한다.

**Tiered 컴파일러**

Tiered 컴파일러는 한마디로 `다단계 컴파일러` 라고 할 수 있다.

특정 메서드가 CompileThreshold만큼 호출되어 JIT컴파일러가 실행될 때 JIT 컴파일러는 바로 최적화가 아주 잘 된 코드(잘된코드)로 컴파일 하지 않는다.

일단은 보통코드(최적화가 그럭저럭 된 코드)로 컴파일을 하게 된다.
그러면 잘된코드로 컴파일 하는 것보다는 실행 중에 지연 시간이 덜 발생하게 된다.

그러다가 그 메서드가 더 많이 호출되어 일정 횟수를 초과하면 그때 잘된코드로 다시 최적화를 하는 것이다.

Tiered컴파일러에서 보통코드로 컴파일 하는 컴파일러를 C1, 잘된 코드로 컴파일하는 컴파일러를 C2라고 한다.

**Code Cache**

그리고 이렇게 컴파일한 기계어는, JVM 안의 `Code Cache` 라는 곳에 저장된다.
Code Cache의 크기 또한 -XX:ReservedCodeCacheSize 옵션으로 지정할 수 있다.

만약 코드 캐시 영역이 꽉 차면 더 이상 JIT 컴파일러가 동작하지 않는다.

컴파일을 하더라도 컴파일된 기계어를 저장할 공간이 없기 때문이다.

참고로 JIT 컴파일러가 실행될 때는 백그라운드 스레드로, 애플리케이션 스레드와 동시에 실행된다고 함

### 시스템 콜이 무엇인지 설명해주세요.

---

![](https://velog.velcdn.com/images/sujipark2009/post/dddd1796-c087-475b-814b-2bfe7b793f96/image.png)

- 운영체제의 커널이 제공하는 기능을 응용 프로그램이 사용할 수 있도록 하는 프로그래밍 인터페이스

- 인터럽트의 한 종류

시스템 구조 -

![](https://velog.velcdn.com/images/sujipark2009/post/8268f4d7-2613-4784-ab28-ed7b1a267a00/image.png)

#### 시스템 콜의 역할은 무엇인가요?

---

- 하드웨어 보호 : 애플리케이션이 하드웨어 자원에 직접 접근하는 것을 막음

- 자원 관리 : 시스템 자원을 할당하고 충돌 없이 공유할 수 있도록 관리

- 표준이 되는 인터페이스 제공

#### 시스템 콜 테이블이란 무엇인가요?

---

- 시스템 콜마다 번호가 할당된다.

- 시스템 콜 번호에 대해 시스템 콜 핸들러 함수 주소를 매핑하는 테이블

- IDT(Interrupt Descriptor Table)라고도 함

#### 우리가 사용하는 시스템 콜의 예시를 들어주세요

---

- fork : 새로운 프로세스를 생성할 때 사용

- exec : 단순 fork는 동일한 프로세스의 내용을 여러 번 동작할 때 사용 / child에서는 parent와 다른 동작을 하고 싶을 때는 exec를 사용할 수 있다

- wait : child 프로세스가 종료될 때까지 기다리는 작업

#### 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해주세요

---

- 시스템 콜 요청 : 응용 프로그램이 시스템 콜을 요청 -> 시스템 콜 번호와 인자 값을 전달

- 시스템 콜 번호와 인자 값 저장 : 인자값은 보통 PCB에 저장 / 시스템 콜 번호는 CPU 레지스터에 저장

- 커널 모드로의 전환 : 특별한 명령인 Trap을 사용

- 시스템 콜 핸들러 실행 : IDT를 참조하여 콜 호출 -> 시스템 콜 번호를 기반으로 핸들러 실행

커널은 하드웨어를 직접 제어 / 메모리를 접근 / 프로세스를 스케쥴링

- 사용자 모드로 전환 : 커널은 다시 사용자 모드로 전환 / 응용 프로그램의 제어를 되돌려 줌

**특징**

- 시스템 콜에는 사용자 모드 전환과 같은 오버헤드 발생 -> 빈번하게 호출되면 성능 저하

- 시스템 콜 테이블을 통한 처리 속도 최적화

#### 시스템 콜의 유형에 대해 설명해 주세요

---

- 프로세스 제어 : 프로세스 생성,종료,프로세스 대기 상태 전환, 프로세스 실행 등 프로세스의 상태를 제어

- 파일 관리 : 파일 생성,삭제,열기,읽기/쓰기,닫기 등 파일 시스템에 관련된 작업을 수행

- 장치 관리 : 장치의 요청,해제,읽기/쓰기,상태 정보 요청
  하드웨어 장치를 관리

- 정보 유지 : 시스템 데이터의 설정/조회, 시간 또는 날짜의 설정/조회

- 통신 : 프로세스 간 통신, 네트워크 통신 등 데이터를 전송하거나 수신

메시지 전달 방식, 공유 메모리 방식 등 다양한 IPC(Inter Process Communication)방식을 포함

#### 운영체제의 Dual Model에 대해 설명해주세요

---

- 컴퓨터 시스템이 두 가지 다른 모드, 즉 사용자모드(User mode)와 커널모드(Kernel Mode)로 동작할 수 있도록 하는 설계 원칙

시스템의 안정성과 보안을 보장하기위한 목표를 가지고 있다.

**사용자 모드**

- 사용자 모드에서 실행되는 프로세스는 제한된 권한을 가지고 있어, 하드웨어에 직접적인 접근을 할 수 없다.

- 시스템 콜을 통해 OS에 서비스를 요청한다

- 실행중인 프로세스의 Local 메모리, 즉 할당받은 메모리에만 접근 가능

**커널 모드**

- 모든 하드웨어 자원에 접근할 수 있는 권한을 가짐
- OS의 핵심 부분은 커널 모드에서 실행
- 사용자 프로세스가 요청하는 시스템 콜을 처리
- 하드웨어 장치를 직접 제어

#### CPU의 Mode bit와 시스템 콜의 관련성을 알려주세요

---

- CPU가 현재 어떤 모드에서 작동 중인지 나타내는 플래그
- 사용자 모드와 커널 모드를 구분

관련성 : 시스템 콜이 일어나면 Mode bit가 전환됨. 1이면 커널 모드

#### 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

---

- 시스템 콜 번호 혹은 ID를 사용

각각의 시스템 콜은 고유한 번호가 할당됨, 이 번호는 사용자 공간에서 커널 공간으로 요청을 전달할 때 사용

- 응용 프로그램이 시스템 콜을 요청 -> 해당 시스템 콜의 번호와 함께 필요한 매개변수를 레지스터에 로드

- 소프트웨어 인터럽트나 특정 명령을 통해 커널모드로 전환 -> 시스템 콜을 처리하는 커널 루틴이 실행

- 커널은 시스템 콜 번호를 확인하고 해당하는 서비스 루틴을 호출 -> 서비스 루틴은 시스템 콜을 처리하고 결과를 사용자 공간에 반환
