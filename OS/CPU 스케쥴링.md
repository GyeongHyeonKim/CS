### CPU 스케쥴링이란?

#### CPU 스케쥴링이란 무엇인가요?

---

- 다수의 프로세스와 스레드가 시스템의 한정된 CPU자원을 공유하며 실행될 수 있도록 관리하는 방법

- 여러 알고리즘을 통해 적절한 프로세스에 CPU를 할당하고, 다른 프로세스에게 양보하거나 회수하는 작업을 수행

![](https://velog.velcdn.com/images/sujipark2009/post/83c5b830-977c-4480-bdac-60439b14a91c/image.png)

- Ready Queue에 있는 프로세스들을 대상으로 함

#### CPU 스케쥴링의 목표는 무엇인가요?

---

- Batch System

가능하면 많은 일 수행 / 시간보다는 처리량이 중요

- Interactive System

빠른 응답시간, 적은 대기시간을 목표

- Real-time System

Deadline에 맞추는게 목표

#### CPU스케쥴리의 성능 척도에는 어떤 것들이 있나요?

---

**시스템 입장**

`**CPU 이용률(CPU Utilization)`

- 시간당 CPU를 사용한 시간의 비율

프로세서를 실행상태로 항상 유지하여, 유후상태가 되지 않도록 함

가능하면 입출력(I/O) 중심의 작업보다, 프로세서 중심의 작업을 수행

`**처리율(Throughput)**`

- 시간당 처리한 작업의 비율

단위 시간당 완료되는 작업의 수가 많도록 하는 것이 목표
짧은 작업을 우선 처리하거나 인터럽트 없이 작업을 실행

**프로세스 입장**

`**반환시간 또는 소요시간(Turnaround Time)**`

- 작업이 시스템에 맡겨져서 메인 메모리에 들어가기까지의 시간

**구성**

Ready Queue에 있는 시간 + CPU Burst time(실행시간) + I/O(입출력 시간)

작업 제출 후 완료되는 순간까지의 소요시간이 최소화되도록 일괄 처리 작업을 우선 처리(FCFS 느낌?)

`**대기 시간(Waiting Time)**`

- CPU Burst 기간 중, 프로세스가 Ready Queue에서 CPU를 얻기 위해 기다린 시간의 합

한 번의 CPU Burst에도 여러 번 기다릴 수 있음

작업의 실행시간이나 입출력시간에는 실제적인 영향을 미치지 못하므로, Ready Queue에서 기다리는 시간이 최소화되도록 사용자 수를 제한

`**반응 시간(Response Time)**`

- 대기열에서 처음으로 CPU를 얻을때까지 걸린 시간

반응시간은, 의뢰한 시간에서부터 반응이 시작되는 시간까지의 간격

특히, 대화형 시스템에서 중요한 사항이다.

대화식 작업을 우선 처리 / 일괄 처리 작업은 대화식 작업의 요구가 없을때 처리

#### CPU Burst Time이란 무엇일까요?

---

- 프로세스가 CPU를 사용하여 작업을 처리하는 연속된 시간

- 입출력(I/O) 작업이 필요하지 않고, 오직 CPU만 사용하는 상태

- 프로세스는 일반적으로 CPU Burst와 I/O Burst를 반복하며 수행

CPU Burst : 프로세스가 계산이나 데이터 처리와 같은 작업을 수행

I/O Burst : 프로세스가 입출력 작업을 수행하거나, 다른 자원을 기다리는 상태

#### 선점 스케쥴링과 비선점 스케쥴링의 차이는 무엇인가요?

---

**선점 스케쥴링(Preemptive Scheduling)**

- OS가 현재 실행중인 프로세스를 강제로 중단하고, 다른 프로세스에게 CPU를 할당할 수 있는 스케쥴링 방식

- 다양한 프로세스의 요구에 빠르게 대응할 수 있다.

- 구현이 복잡하고 오버헤드가 증가

ex: Round Robin, Priority Queue, Multilevel Queue Scheduling

**비선점 스케쥴링(Non-Preemptive Scheduling)**

- CPU를 할당받은 프로세스가 작업을 완료하거나, 자발적으로 CPU를 반납할 때까지 다른 프로세스에게 CPU를 넘기지 않는 방식

- 구현이 간단하고 오버헤드가 적음

- 단, 대기시간이 길어질 수 있음

ex: FCFS, SJF

### 프로세스의 스케쥴링 상태에 대해 설명해주세요

---

![](https://velog.velcdn.com/images/sujipark2009/post/1e1b626c-5fd1-4dfa-831a-d09ae46b6288/image.png)

**New**

- 프로세스를 생성하고 있는 단계
- 커널 공간에 PCB가 만들어진 상태

**Ready**

- 프로세스가 CPU를 기다리는 상태
- 프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻은 상태
- 아직 CPU를 받지는 않았지만, CPU만 할당받으면 바로 실행 가능한 상태
- Ready 상태의 여러 프로세스가 동시에 존재 가능

**Running**

- 프로세스가 CPU를 할당받아 명령어를 수행중인 상태
- CPU가 하나이기에, 매 시점 항상 하나만 존재

**Blocked**

- 프로세스가 CPU를 할당 받아도 당장 실행할 수 없는 상태
- 현재 프로세스가 I/O 작업 등을 처리중인 상태
- Device Queue에서 줄을 서게 됨

**Suspended**

- 프로세스의 중지 상태
- 메모리를 강제로 뺏긴 상태로, 특정한 이유로 프로세스의 수행이 정지된 상태
- 외부에서 다시 재개시키지 않는 이상 다시 활성화 될 수 없음
- 중기 스케쥴러에 의해 디스크로 스왑 아웃된 프로세스의 상태가 대표적인 Suspended상태

Suspended ready : 준비 상태에 있던 프로세스가 디스크로 스왑아웃
Suspended blocked : block 상태에 있던 프로세스가 디스크로 스왑아웃

**Terminated**

- 프로세스가 CPU를 할당 받아 주어진 시간 내에 완전히 수행을 종료한 상태

#### Blocked 상태는 왜 필요한가요?

---

- Running 상태에서, I/O 작업이 필요한 경우

디스크 I/O 작업은 CPU 처리 속도에 비해 오래 걸리는 작업

디스크 I/O 작업 동안은, CPU를 점유하고 있어도 다음 명령어를 수행하지 못함 - CPU 낭비

- 장치 큐에 줄을 서는 상태

- Disk Controller

마그네틱 원판에서 원하는 데이터를 로컬 버퍼로 읽어오고 나면, 디스크 컨트롤러에 의해 서비스를 받아 일을 수행

디스크 컨트롤러가 CPU에게 일이 끝났음을 알리기 위해 interrupt를 발생시킴

- Blocked -> Ready

인터럽트를 받아 장치 큐에서 제거하고 Ready Queue로 이동
프로세스 A가 한 일(로컬버퍼에 저장된 데이터)은 메모리에 전달 됨

#### Blocked와 Suspended의 차이는 무엇인가요?

---

**Blocked** - 잠시 중지되어있다 끝나면 다시 Ready 상태로 돌아옴
**Suspended** - 잠시 중지되어 있다가 누군가가 재개시켜줘야 다시 ready상태로 돌아옴

#### 프로세스를 스케쥴링 하기 위한 큐에는 어떤 것들이 있나요?

---

**작업큐(Job Queue)**

- 시스템의 모든 프로세스를 관리하기 위한 큐
- 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스를 관리
- 작업 큐에 있다고 해서 반드시 메모리를 가지고 있는 것은 아님

**준비 큐(Ready Queue)**

- CPU를 할당받기를 기다리고 있는 프로세스들을 관리
- 프로세스들을 줄 세우는 방법으로 스케쥴링 알고리즘(어떻게 공평하게 CPU를 나눠줄까?)을 사용

- 준비 큐에 있는 프로세스들은 준비 상태

**장치 큐(Device Queue)**

- 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스들을 관리
- 장치 큐에 속한 프로세스는 Blocked 상태

**과정**

- Block 상태에 있다가 해당 장치의 서비스를 받음
- 장치 컨트롤러가 인터럽트를 발생
- 준비 상태로 바뀌어 준비 큐로 이동

#### Process 상태 전이에 대해 설명해주세요. 디스패치, 타이머 런 아웃과 같은 용어를 사용해주세요

---

**New -> Ready**

프로세스가 처음 생성이 완료되어 메모리에 로드되면, 프로세스의 상태가 New에서 Ready로 전환

**Ready -> Running**

준비 리스트에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU 할당

디스패처가 해줌

**Running -> Ready**

타이머 런 아웃 - 지정된 시간이 초과되면 CPU 반납 후 다시 준비상태로 전이

인터럽트 - 현재 프로세스보다 우선순위가 높은 프로세스가 Ready Queue에 존재하는 경우, 프로세스의 소유권이 넘어감

**Running -> Blocked**

지정된 할당 시간을 초과하기 전 I/O 또는 기타 사건이 발생하는 경우

**Blocked -> Ready**

I/O가 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 알려주고 Ready로 전이

**Running -> Terminated**

프로세스 실행이 완료되어 자원을 반납한 경우

**Blocked,ready -> suspended blocked,suspended ready**

suspended blocked인 프로세스가 봉쇄되었던 조건을 만족하게 되면 suspended ready 상태로 전이

suspended 상태에 있는 프로세스들은 메모리를 조금도 보유하지 않고 디스크로 통째로 swap out 된 상태

#### Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

---

중기 스케쥴러가 아래의 작업을 수행

- Suspended상태로 전환

Running -> Suspended Ready
Blocked -> Suspended Blocked

- 메모리가 다시 사용 가능해지면

OS는 일시 중단된 프로세스를 메모리로 다시 로드.
프로세스의 상태를 원래 상태로 되돌림(Resuming)

#### 선점,비선점에서 존재할 수 없는 상태전이가 있을까요?

---

비선점의 경우, Running -> Ready가 없음

#### 단기,중기,장기 스케쥴레에 대해 설명해주세요

---

`**단기 스케쥴러**`

- CPU 스케쥴러이다.

ready 상태에 있는 프로세스 중 어떤 프로세스를 실행 상태로 만들 것인지 결정, CPU를 할당

타이머 인터럽트가 발생하면 단기 스케쥴러가 호출된다.

**목표**

- 공정한 CPU 할당과 시스템의 전반적인 성능 최적화

**알고리즘**

Round Robin, Priority-Based, Shortest Job First 등

**속도**

단기 스케쥴러는 ms이하의 시간단위로 매우 빈번하게 호출 -> 수행 속도가 충분히 빨라야 함

`**중기 스케쥴러**`

- 메모리 스케쥴러라고 함

프로세스가 메인 메모리와 디스크 간에 스왑되는 타이밍을 관리

메모리 부족으로 인해 메모리를 해제할 필요가 있는 경우 / 메모리에 있는 프로세스 중 일시적으로 중단되어야 할 경우 사용

**필요성**

- 메모리에 많은 수의 프로세스가 적재되어 프로세스 당 보유하고 있는 메모리량이 극도로 적은 상황

- CPU 수행에 당장 필요한 프로세스의 주소공간조차도 메모리에 올려놓기 어려움

- 디스크 I/O가 수시로 발생

- 시스템의 성능이 심각하게 저하

- 메모리에 올라와 있는 프로세스 중 일부로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장

...

- 프로세스의 일시 중지와 재개에 관여
- Swapping 이라는 기술을 사용하여 메모리를 관리

**우선순위**

Block 상태에 있는 프로세스들을 첫번째로 스왑아웃(당장 CPU를 획득할 가능성이 없기 때문)

타이머 인터럽트가 발생해 ready queue로 이동하는 프로세스를 추가적으로 스왑아웃

`**장기 스케쥴러**`

- 작업 스케쥴러라고도 함

프로세스를 시스템에 언제 로드할지 결정

어떤 프로세스를 ready queue에 삽입할지 결정 / 디스크에서 어떤 프로그램을 가져와 커널에 등록할지(ready queue에 등록할지)결정

메모리에 동시에 올라가 있는 프로세스의 수를 조절

프로세스 상태도에서 프로세스가 생성되면 바로 ready상태가 되는게 아니라, admitted되면 ready 상태가 되는데, 이 admit을 해주는게 장기 스케쥴러이다.

처음에 프로세스가 시작될 때 메모리에 들어오도록 허락해주는게 장기 스케쥴러의 역할이다

**목표**

- 시스템 내의 동시 실행 프로세스의 수를 조절하여 효율적인 시스템 활용을 유지하는 것

- 입출력 중심 프로세스와 CPU 중심 프로세스를 적절히 섞어, 전체 성능을 향상

- 수십 초 내지 수 분 단위로 가끔 호출 -> 속도가 느린 것이 허용

#### 현재 OS에는 단기,중기,장기 스케쥴러를 모두 사용하고 있나요?

---

단기 스케쥴러 - 실행 중인 프로세스에 대해 CPU를 할당하는 데 사용

중기 스케쥴러 - 잘 사용하지 않음.

가상 메모리에 의해 대체 -> 과거와 달리 프로세스 전체가 아닌 일부만 올려도 되기 때문

장기 스케쥴러 - 일반적으로 사용하지 않음

일괄처리 시스템에서 사용 - 자원독점

현대는 대부분 시분할 RR방식 사용 - 자원 독점X

가상 메모리에 의해 대체

#### CPU 스케쥴링 방법에는 어떤 것들이 있나요?

---

**FCFS(First-Come,First-Served)**

가장 먼저 도착한 프로세스부터 순서대로 CPU를 할당하는 방식

단순하고 공평하지만, 평균 대기 시간이 길어질 수 있음

비선점

**SJF(Shortest Job First)**

**비선점형**

- 각 프로세스의 예상 실행 시간을 기준으로, 가장 짧은 작업을 먼저 실행하는 방식

최소 평균 대기시간을 보장

단, 실행 시간 추정이 어렵고 긴 작업의 경우 계속 대기하는 `starvation`의 가능성이 존재

**선점형**

\*\*SRTF(Shortest Remaining Time First)

- SJF의 선점형 스케쥴링 방식

남은 프로세스의 burst time보다 더 짧은 process가 도착하면 CPU를 빼앗음

- 프로세스가 새로 들어올때마다 갱신

단, 낮은 순위의 프로세스가 계속 대기해야하는 starvation의 가능성 /
새로운 프로세스가 들어올때마다 스케쥴링이 변경되므로, CPU 사용 시간을 정확히 예측하기 어렵다.

일종의 우선순위 스케쥴링

**Priority Scheduling**

- 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스부터 CPU를 할당하는 방식

선점형 / 비선점형 모두 존재

- 중요한 작업을 먼저 처리할 수 있음

- starvation의 가능성이 있으나, `Aging` 기법으로 큐에 남아있었던 시간으로 가중치를 부여 가능

**Round Robin**

- `Time Quantum`

각 프로세스에 일정 시간 할당량을 부여하고, 순환방식으로 CPU를 할당하는 방법

할당 시간이 지나면 프로세스는 선점 당하고 Ready Queue의 맨 뒤로 가게 된다.

선점형 스케쥴링 기법

**장점**

- 공평한 스케쥴링을 제공하며, 평균 대기 시간을 적절하게 유지할 수 있음

- CPU 사용시간이 랜덤할때 더욱 효율적

- 평균 대기 시간은 조금 길어질 수 있으나 **응답시간(response time)** 이 짧아짐 -> CPU를 최초로 얻기까지 걸리는 시간이 짧아짐

- SJF보다 평균 **Turnaround time**은 길지만, 응답시간은 짧음

- 적절한 시간 할당량 설정이 중요

**Multilevel Queue**

- 프로세스를 여러 우선순위 큐에 분류하고, 우선순위 큐부터 순차적으로 CPU를 할당하는 방식

- 큐 내에서는 다른 스케쥴링 알고리즘이 사용될 수 있음

- 프로세스의 중요도에 따라 관리하여 효율을 높임

단, 한번 큐에 들어가면 다른 큐로 이동하거나 변경이 불가

**Multilevel Feedback Queue(MFQ)**

![](https://velog.velcdn.com/images/sujipark2009/post/0e4adbf6-199a-4242-be27-44eacbaa2a7e/image.png)

- 다중 레벨 피드백 큐는 멀티 레벨 큐 스케쥴링의 변형으로, 프로세스가 시간 할당량을 다 사용하지 않으면, 더 낮은 우선순위 큐로 이동

- 가장 아래의 백그라운드 프로세스는 FCFS로 처리

**원리**

- time quantum을 다 채운 프로세스가 아래 단계로 이동함

CPU Burst가 높다는 것은, 상호작용할 가능성이 낮다는 것으로 판단

ex) 다운로드와 같은 프로세스는 상호작용이 없고 CPU만 일을 함

**장점**

- 동적으로 프로세스의 우선순위를 조정하여 실행시간이 짧은 프로세스에 빠른 응답을 제공

- 유연성이 뛰어남

- starvation을 줄이는 효과 -> 그러나 여전히 발생가능

**단점**

- 구현이 복잡하다
- 적절한 큐와 시간 할당량 설정이 중요하다.

#### Round Robin에서 time quantum에 따라 어떤 차이가 발생하나요?

---

- q time unit이 커지면 FCFS와 같아져 비효율적일 수 있다

평균 대기시간이 길어짐

- q time unit이 지나치게 작으면, Context switching이 대량으로 발생해 오버헤드가 증가한다

#### Convoy Effect(호위 효과)란 무엇인가요?

---

- 하나의 프로세스로 인해 다른 프로세스들이 기다리는 현상

- FCFS와 같은 알고리즘에서 발생 가능

긴 process 뒤에 여러 짧은 process들

#### 싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는게 좋을까요? 또 왜 그럴까요?

---

Round Robin

- 언제 끝날지 모르기 때문
- 다른 작업과 공정하게 수행하여, 반응성을 높이는 것이 중요함
