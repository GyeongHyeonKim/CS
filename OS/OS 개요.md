### 배경지식

#### 운영체제란 무엇인가?

---

![](https://velog.velcdn.com/images/sujipark2009/post/4a061197-a812-468c-9cc2-a6ce6b6288a2/image.png)

OS란, 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.

- 자원을 효율적으로 관리하는 역할을 한다.

좁은의미의 OS는 `커널` 이라고도 한다.

- 메모리에 항상 상주하는 운영체제의 가장 핵심적인 부분이다.

#### OS의 목적

---

여러 사용자 및 프로그램들이 컴퓨터를 편리하게 사용할 수 있는 인터페이스를 제공한다.

컴퓨터가 어떻게 작동하는지는 모르지만, 그냥 사용하면 된다.
구체적으로는 `자원을 효율적으로 관리` 하는 역할을 한다.

자원이라하면, CPU,Memory,Disk 등의 하드웨어 자원도 있고, 소프트웨어 자원도 존재한다.

가장 중요한것은, 주어진 자원으로 최대한의 퍼포먼스를 내는 것이다.
또한, 형평성있는 자원분배도 필요하다.(누구한테 CPU를 먼저줄까, 메모리는 얼마나 줄까.. 그런 것)

한정된 메모리 공간에 동시에 프로그램이 돌아가는데.. 그럴때는 어떻게 해야할까?
이런 것을 관리하는 역할이다.

#### 용어

---

**Multitasking** : 컴퓨터 안에서 프로그램을 여러개 돌리는것을 의미한다.

**Multiprogramming** : 메모리 측면을 더 강조한것으로, 메모리에 여러 프로그램이 동시에 올라가있는것을 의미.

**Time Sharing** : 시간을 공유한다는 의미. CPU가 짧은 시간간격으로 Time sharing을 하기에, CPU쪽을 더 강조하는 의미

**Multiprocessor** : 컴퓨터안에 CPU가 여러개 붙어 있음을 의미. 이 경우, CPU에서 하나의 Memory를 공유해서 사용하기때문에 문제가 생길 수 있다.

#### OS의 구조

---

![](https://velog.velcdn.com/images/sujipark2009/post/e05a62d7-c4ed-4108-ab3a-b741992d5377/image.png)

#### System Structure & Program Execution

---

![](https://velog.velcdn.com/images/sujipark2009/post/425e716e-2f6e-4bc0-8a9d-0a71e03362fe/image.png)

컴퓨터 전원을 켜면, OS가 메모리에 상주하게 되고 프로그램을 켜면 메모리에 프로그램이 올라가서 **프로세스** 가 된다.

- IO 장치들에는 그 IO 장치들을 전담하는 작은 CPU가 있는데, 그것들을 `Device Controller` 라고 한다.

키보드를 관리하는 Keyboard Controller.. Disk를 관리하는 Disk Controller.. 등이 있다.

- CPU는 기계어를 실제로 연산하는 기능을 가지고 있고, 그런 연산을 하기 위해서는 본인의 작업공간이 필요한데, 그것이 바로 `Memory` 이다.

Memory 또한 디바이스기 때문에, 이것을 전담하는 Memory Controller 라는게 붙어있다.

- 각각의 Device Controller들도 작업공간이 있는데, 이것을 `Local Buffer` 라고 한다.

- CPU에서 기계어를 실행을 할텐데, 그 기계어 또한 메모리의 어느 부분에 상주하고 있을 코드이다.

**운영체제 부분**에 있을수도 있고, **사용자 프로세스 내부**에 있을수도 있는데 이 2가지가 구분될 필요가 있다.

CPU가 OS에 의해서 실행될때는, 아무거나 다 할 수 있다.

운영체제가 사용자 프로그램에게 CPU를 넘겨줄텐데, 그 프로그램은 **악의적인 프로그램**일 수도 있다.

일단 CPU가 사용자 프로그램에게 넘어가면 OS는 그걸 제어할 방법이 없다.

OS는 명령어를 통해 CPU를 제어하고 그 명령어는 CPU에 의해서 실행이 될 때 의미가 있는건데, CPU가 넘어가면 제어할 방법이 없다는 것이다.
그래서 CPU는 지금 OS가 실행하는지, 사용자 프로그램이 실행하는지를 구분하고 있는데 그게바로 `Mode bit` 이다.

Mode bit이 0이면 OS가 사용하는 상황이고, 1이면 사용자 프로그램이 사용하는 상황이다.
1인경우, 사용자 프로그램은 아무거나 다 할 수 있는게 아니라 위험한 기계어는 실행할 수 없도록 제어할 수 있다.
그런 위험한 기계어를 `특권 명령` 이라고 한다.

![](https://velog.velcdn.com/images/sujipark2009/post/bdb5b778-2559-40b1-82f9-b4fb67bc8c61/image.png)

그래서 만약 사용자 프로그램이 명령어를 실행하고 있다면, 그 명령어를 실행하기 전에 `특권명령` 인지 아닌지를 CPU가 보고, 만약 특권명령인데 mode bit이 0이 아니다?
그럼 불순한 의도를 감지하고, 자동적으로 CPU가 OS에게 넘어가게 된다.

CPU가 OS에게 넘어가는 방법은 `Interrupt` 와 `Exception` 이라는 방법이 있는데
`Exception` 이라는게 방금말한 예외상황이다.

권한이 없는 기계어를 실행하려고 할 때, mode bit이 0으로 바뀌면서 자동으로 OS에게 권한이 넘어가는 것이다.

`Interrupt` 가 뭐냐면,, CPU에는 `Interrupt line` 이라는게 있는데 CPU는 매번 명령어를 수행하면서, 수행하기 직전에 Interrupt line을 확인해서 혹시 `Signal` 이 들어온게 있는지를 확인하게 된다.

이런 Interrupt는 Device들이 발생시킬 수 있는데, 프로그램 A가 실행되다가 디스크에서 어떤 파일을 읽어와야 한다고 해보자.

그럼 CPU가 디스크를 직접 읽는게 아니라, 디스크에게 어떤 파일좀 읽어달라고 부탁을 하게 된다.

그럼 Disk Controller가 일을하게되고, 그동안 CPU는 OS를 통과한 다음에 다른 프로그램에게 넘어가게 된다.
그리고 Disk Controller가 일을 다 했으면, 그걸 OS에게 **알려줘야 한다**

알려주는 방법이, CPU에게 Interrupt를 거는것이다.

CPU는 무언가 일을 하고 있었을텐데, 그 다음 명령어를 수행하기에 앞서서 Interrupt line을 확인하고 Interrupt가 있다면, OS에게 CPU가 넘어가게 된다.

mode bit이 0으로 바뀌고 OS가 그 Interrupt에 해당하는 일을 수행하게 된다.

CPU안에는 register라는게 있는데, 연산을 하는 과정에서 생기는 중간값을 저장하기 위한 아주 빠르고 작은 메모리라고 생각하면 된다.

register중에서는, `Program Counter` 라는 register가 있는데, 이것은 **다음번에 수행할 명령어의 메모리 주소**를 가리키고 있다.

...

- OS가 프로그램 A에게 CPU를 넘겼는데, 만약 A가 무한루프를 돌아서 CPU를 안내놓고 있는다면 어떻게 될까?

그럴때는, CPU 사용권을 뺏어와야 하는데 그것은 OS혼자 할 수 없는 일이다.

OS라는것도 결국 CPU를 통해 명령어를 실행하면서 자원을 관리하는 것이기 때문이다.

이것을 위해서는 부가적인 하드웨어가 필요한데, 그게 바로 `Timer` 라는 하드웨어이다.

일정 시간간격으로 Interrupt를 발생시키는 역할을 한다(Timer Interrupt).

OS가 사용자 프로그램 A에게 CPU를 넘길 때 그냥 넘기는게 아니고 Timer에다가 시간을 설정한 후에 넘기게 된다.

그래서 만약 A가 무한루프를 돌아도, Timer가 interrupt를 걸기때문에 CPU가 OS에게 자동적으로 넘어가게 된다.

그리고 그때 OS는 CPU를 뺏어서 다른 프로그램에게 CPU를 넘겨줄 수 있다.

Timer는 `Time Sharing`을 구현하기 위해 널리 이용되며 CPU Scheduling에 사용된다.

...

프로그램 A가 실행하다가 파일을 읽고싶을 때가 있다해보자.
그런데, 이 파일이 있는 부분은 CPU가 직접적으로는 접근할 수 없게 되어있다.

그래서 CPU가 해당 Disk를 담당하는 Controller에게 부탁하게 되는데, 여기서 부탁을 하는것도 사실 `기계어` 이다.

그리고 그러한 기계어는, 기계어 종료중에서도 `특권명령` 으로 규정되어있는 명령어이다.

모든 IO장치를 접근하는, 다시말해서 CPU가 IO를 해달라고 부탁하는 그런것들을 특권명령으로 구분되어있다.

그런것들은 OS에게 해달라고 요청해야한다.

그런걸 `시스템 콜(System Call)` 이라고 한다.

- 사용자 프로그램이 뭔가를 하고싶은데, 내 권한을 가지고는 할 수 없는 그러한 특권명령의 기계어를 OS에게 부탁하기 위해 사용한다.

사용자 프로그램이 OS커널에 있는 함수를 호출하는 것이다.

프로그램 A가 돌다가 파일을 읽어와야 한다면, 내가 가진 명령어를 CPU로 읽어서는 그런 특권명령을 못하기 때문에, **스스로 운영체제를 불러서 요청을 해야한다.**

그게 바로 **시스템 콜** 이며, 콜을 하면 프로그램 영역의 기계어에서 OS영역의 기계어로 Jump를 해야한다.

근데 이것도 그냥 할 수 있는게 아니라, 무언가 방법이 필요하다,, 내가 기게어를 실행하다가 CPU를 OS에게 넘기고 싶은건데, 이걸 위해서는 Interrupt line에 interrupt가 들어오게 해야한다.

CPU는 아까 매 명령어의 실행전에 interrupt line을 검사하여, interrupt가 있는경우 OS에게 CPU를 넘긴다고 했다.

지금 내가 IO를 하고싶은데, 그건 OS만 해줄 수 있으니 프로그램이 스스로 interrupt를 거는데 그걸 **시스템 콜**이라고 하는 것이다.

내가 CPU를 OS에게 넘기기 위해서, 직접 PC(Program Counter)를 이동시킬 수 없기 때문에 이 프로그램이 자신의 기계어를 이용해서 interrupt line을 세팅하게 된다.

그러면 CPU가 다음 명령어를 수행하기 전에 interrupt가 들어왔으니까 CPU제어권을 OS에게 넘기는 것이다.

그럼 다시말하면

기존의 interrupt는 Device Controller가 CPU에게 정보를 전달하기 위해 거는거였는데(디스크를 다 읽었다거나.. 그런 정보), 지금 말한 interrupt는 어떤 소프트웨어가 본인이 할 수 없는 일을 OS에게 부탁하기 위해 자신의 코드를 통해서 interrupt를 거는식으로 동작하게 되는 것이다.

그리고 이걸 **시스템 콜**이라고 하며, 이런 interrupt를 `Software interrupt`라고한다.

그럼 자동적으로,, 앞에 있던 interrupt(Device Controller가 거는 것)는 `Hardware interrupt`가 되는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/d1606679-e9df-4894-a086-735ce1731693/image.png)

일반적인 인터럽트는 하드웨어 인터럽트를 말하며 방금말한, 소프트웨어가 발생시키는 인터럽트를 특별하게 `Trap` 이라고 말한다.

어떤 프로그램이 OS에게 부탁하고 싶은데 직접 Program Counter를 OS영역으로 옮길 수 없기 때문에 OS에게 넘기는 방법이 바로 시스템 콜 이라고 생각하자.

...

전에 말했던, 프로그램이 이상한 짓을 해서 OS에게 CPU가 넘어가고 이 프로그램을 혼낼 필요가 있을 경우 무슨일이 일어나냐면

프로그램이 본인에게 권한이 없는 명령어를 수행하려고 하면, CPU가 mode bit을 체크해서 "어? 이XX 이상한짓 하려고 하네?" 하고 `Trap` 이 걸리면서, CPU가 OS에게 넘어가게 된다.

이것또한 사실 소프트웨어가 interrupt line을 세팅하는 방식으로 이루어지기 때문에 이것도 소프트웨어 인터럽트로 간주한다.

그래서 요약하자면,,

- 프로그램 A가 실행되다가 파일을 읽을 일이 생김.

- 이런건 IO작업인데, IO는 특권명령이므로 자신의 명령어로는 불가능한 일이니까 OS에게 시스템 콜을 한다.

- OS는 CPU를 통해 Disk Controller에게 부탁을 하게 된다.
- Disk Controller가 읽는 작업은 오래 걸리는 작업이다.

- CPU는 그 작업을 맡겨두고 CPU는 다른 프로그램에게 CPU를 넘겨서 명령어를 수행할 수 있도록 한다.

- Disk를 다 읽었으면, CPU에게 인터럽트를 걸어서 CPU제어권이 OS에게 넘어가게 된다.

- OS는 요청했었던 결과를 메모리 위치에 읽어와서 프로그램 A가 읽을 수 있도록 해준다.

- A가 CPU제어권을 얻으면, 해당 결과를 가지고 자신의 명령어를 수행할 수 있게 된다.

...

- CPU는 하드웨어일까 소프트웨어일까?

당연히 하드웨어이다. 메모리 어딘가에 있는 기계어를 실행하는 역할을 한다.

- Device Controller는 ?

이것도 하드웨어이다. 마찬가지로 어딘가에 기계어가 있고 그걸 실행하게 되는데
이런 IO장치들에는 IO장치들의 `펌웨어` 라고 해서, 미리 안에 코딩된 프로그램들이 들어있다.

이런 펌웨어에 의해 Device Controller가 동작하게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/f5a8cf84-d53f-4295-8310-64c46b2868d3/image.png)

그런데,, Device Driver라는게 있는데 이건 Software이다.

아까 운영체제 안에 있는 코드 중에서 CPU가 IO장치에게 부탁하도록 하는 코드가 있다고 했는데 그게 바로 `Device Driver` 이다.

부탁하는 방법이 적혀있는게 `Device Driver`이다.

그래서 Driver라는건, Device Controller가 수행하는 코드가 아니라 CPU가 수행하는 코드이다.

Device Controller도 무언가 코드가 있어서 그 코드에 의해서 Disk의 내용을 읽거나 쓰거나 할 텐데 그게바로 `Firmware` 인 것이다.

- OS는 ?

소프트웨어이다.

...

Q. OS에게 CPU가 넘어가는 경우는 어떤 경우가 있을까?

3가지 정도가 있는데, 이것들의 공통점은 Interrupt line을 Setting하는 경우에 한해서 CPU가 OS에게 넘어온다는 것이다.

그리고 이 Setting도 누가 하느냐에 따라 2가지로 구분이 되는데,

1. 하드웨어 장치들이 인터럽트를 걸어서 CPU가 OS에게 넘어가는 방법

2. 프로그램 소프트웨어가 직접 Interrupt line을 Setting하는 방법

- 그 중에서는 `시스템 콜` 이라고 해서, 사용자 프로그램이 본인의 힘으로는 실행할 수 없는 `특권 명령` 코드(IO 요청 등..)가 존재하기 때문에 OS가 실행시켜야 할 필요가 있다.

- 근데 이거는 내가 못하니까 부탁하기 위해 Interrupt line을 Seeting하는것이고 이걸 좁은 의미로는 소프트웨어 인터럽트, `Trap` 이라고 부른다.

- 프로그램이 실행되다가 Exception(0으로 나누거나, 권한이 없는 기계어를 실행)이 생기는 경우 인터럽트가 발생하여 CPU가 OS에게 넘어가게 된다.

3. Timer가 걸어준 인터럽트

- 너만 너무 오래쓰면 안되니까 인터럽트 걸어주는 것

...

`인터럽트 벡터` 라는게 있는데, 인터럽트 종류별로 해당하는 종류의 인터럽트가 발생했을 때, OS의 어디에 있는 코드를 실행해야 하는지를 알려주는 일종의 배열이다.

Timer인터럽트는 여기,, Disk Controller의 경우 저기.. 이런식으로 각 종류별로 너는 어디로 너는 저기로 이런것을 나타내주는게 벡터이다.

**Interrupt Service Routine(ISR)**

- 해당하는 인터럽트를 처리하는 커널함수이다.

현대의 운영체제는 인터럽트에 의해 구동된다고 할 수 있다.

OS도 하나의 프로그램이기 때문에, 언제든지 CPU를 뺏을 수 있는건 아니고 인터럽트가 들어오는 경우에 한해서 CPU를 쓸 수 있게 정의되어 있다.

OS의 역할이 필요한 경우 -> 인터럽트를 통해서.
CPU의 독점을 막기위해서는 -> Timer라는 하드웨어를 통해서 OS가 호출되도록.
IO장치와 CPU간의 연락이 필요할때는 -> IO장치가 CPU에게 인터럽트를 거는.

이런 방식을 통해 OS가 CPU를 쓸 수 있도록 되어있다.

#### 동기식 입출력 / 비동기식 입출력

---

![](https://velog.velcdn.com/images/sujipark2009/post/aa274500-795c-4cc8-83ce-be2fb489cbda/image.png)

동기식 입출력(Synchronous I/O)..

사실 이건 한국말에는 없는말이다.

뭔가 여럿이 같이 뭔가를 함에 있어서 시간적으로 잘 맞아떨어지게 하는것을 의미한다.

수영 종목중에 Synchronized Swimming이라고 있는데, 여럿이 시간에 맞게 조율을 해서 동작을 하는데에 의미가 있다.

또한, 가수들이 노래를 부르는데 라이브로 부르는게 아니라 녹음된걸 틀고 뻐끔뻐끔거리는걸 립싱크라고 한다.

이게 동기의 의미이다.

그래서 OS에서 Synchronous 라는 말은 종종 등장하지만, 세부적으로 살펴보면 매번 다르긴하다.

동기식 I/O라는건, CPU가 IO요청을 하고 IO에서 일어나는 작업과 CPU에서 일어나는 작업이 Sync가 되어야 하는 것을 의미하고. Sync가 필요없는것을 비동기식이라고 부른다.

좀 구체적으로 살펴보면,

시스템 콜을 해서 Disk에게 I/O 요청을 하면, I/O가 끝나서 마무리가 되었을 때 Disk Controller가 CPU에게 인터럽트를 걸면 그 결과를 보고 다음 Step을 밟아나가는 것을 동기식이라고 부른다.

비동기식은, CPU가 disk에 요청을 한 다음에 disk가 뭘 하던지 신경쓰지 않고 다음 Step을 밟는것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/e24dbc31-e7bc-4a8b-97dd-d97d7abbad71/image.png)

그래서 동기식 입출력은,

- 사용자 프로그램이 입출력 요청을 하는데 본인 스스로는 못하기에 OS의 커널을 통해서 Disk Controller에게 파일을 읽어달라 요청을 한다.

- 그 작업은 대단히 오래걸리는 작업이기에, 그 동안 입출력 요청을 한 친구는 뭐가 읽힐지 모르기 때문에 그 동안 기다리게 된다.

- 읽기 작업이 끝나면 Disk Controller가 CPU에게 인터럽트를 걸어서 끝났음을 알려주고 그걸 읽고 다음 작업을 하는게 **동기**

비동기는,

IO요청을 하고 결과와는 무관하게 곧바로 IO요청을 한 친구에게 CPU를 주고 다음 일을 하도록 시키는 것이다.

...

상식적으로 보면 비동기식 입출력이 가능할까?

대게 IO요청을 했다는 것은, 바로 그 다음 기계어에서 그 내용을 보고 무언가 작업을 하겠다는게 아닌가?

그래서 일반적으로는 동기식을 사용하지만, IO 요청을 해서 결과값을 얻기 전에 그 전에도 작업을 할 수 있는게 있다. 다시말해서, **IO 결과를 모르는 상태에서 그것과 무관한 일을 미리 할 수도 있다**

IO가 어떤 파일을 읽어와라~ 그런거면 동기적으로 해야겠지만, 파일에게 어떤 내용을 쓰라는 요청이면?

요청을 보내고 실제로 써지던 말던 나는 다른일을 할 수 있는 것이고, 다 써지면 "다 써졌어요!!!" 하고 연락만 받는것이다.

다만, 나는 써진걸 꼭 확인하고 다음작업을 하겠다고 하면, 동기적으로도 할 수 있다.

동기식은 어쨌든 IO가 다 끝나면 그걸보고 다음 작업을 하도록 하는 것

그 사이에 시간이 오래걸릴텐데, 이 프로그램이 마냥 기다리고 있으면 CPU가 낭비가 될 것이다. 그래서 보통은 동기식 입출력을 하면 IO요청을 해놓고 인터럽트가 들어와서 다른 프로그램에게 CPU를 넘겨주게 된다.

CPU는 비싼자원이라 놀게하면 안되기 때문이다.

그렇게 하면 동기식 입출력의 조건을 만족하면서 CPU가 다른 프로그램에게 넘어가니 더 효율적이다.

IO요청을 하고 기다리는 동안 CPU를 잡고있으면, CPU도 낭비지만 **IO장치도 낭비가 된다.**

왜 그러냐면...

- CPU를 쓰다가 IO요청을 함(디스크 읽기)

그동안 CPU를 안놓으면 시스템 안에서 IO는 매순간 1개씩만 진행이 될 것이다.

근데 내가 IO요청을 해서 Disk I/O가 일어나는 동안 다른 프로그램에게 CPU를 넘기면 그것도 일을 하다가 IO를 요청해서 다른 기기(키보드/마우스)등을 돌릴 수 있다.

그럼 IO장치에도 여러 프로그램들이 와서 줄을 서게 된다.

그렇게 되면 IO도 여러곳에서 일어나고 + CPU도 안쉬고 이런식으로 진행이 될 수 있다.

#### DMA(Direct Memory Access)

---

CPU는 대단히 빠른 자원이기에, 놀지않고 계속 일을 하고 IO장치들이 CPU에게 메시지를 전달해야 하는 경우 인터럽트를 건다고 했었다.

근데 이 인터럽트가 너무 자주 걸리게 된다면?

인터럽트 처리도 사실 일종의 `Overhead` 이다. 인터럽트가 들어오면 하던 작업을 멈추고 CPU가 OS에게 넘어가서 다른 작업을 하러 가야한다.

IO장치들은 CPU에 비해 상당히 느리다.

그래서 인터럽트는 CPU의 입장에서 보면 그렇게 빈번한 일은 아니다(단, Timer 인터럽트는 다르다)

사실 IO장치중에는 고속 IO장치도 있는데 그런 장치들은 매번 IO가 끝날때마다 인터럽트를 걸면 너무 자주걸려서 CPU에게도 비효율적인 상황이 생긴다.

그래서 `DMA(Direct Memory Access) Controller` 라는걸 붙여놓는다.

메모리를 접근할 수 있는 장치는, CPU밖에 없다.

Disk Controller가 파일을 읽는 작업이 끝났다고 해서, Disk Controller가 직접 그 내용을 메모리에 올려놓지 못한다.

왜냐하면 메모리는 **CPU의 작업공간**이기 때문이다.

그래서 메모리를 접근할 수 있는 장치를 하나 더 둔게 DMA이다.

인터럽트가 너무 자주걸리는 것을 막기위해 도입된 것이다..!

아주 작은 데이터가 Local Buffer에 들어왔다고 해서 그때마다 Controller가 직접 CPU에게 인터럽트를 거는게 아니라, 특정 분량이 채워졌을 때 DMA가 직접 메모리에 Copy하는 작업을 해준다.

![](https://velog.velcdn.com/images/sujipark2009/post/efa57d36-b214-40e7-bc75-efb0a019ddb2/image.png)

요약하자면, Disk Controller가 직접 메모리에 접근하지 못하니 인터럽트를 걸고 CPU가 Local Buffer에서 읽어가라고 하는 방식이 너무 인터럽트가 많이 발생하고 비효율적이라서 DMA라는 Controller를 통해 직접 메모리에 올려놓고 CPU에게 인터럽트를 걸어서 한번에 알려주도록 하는 방식이다.

#### 운영체제란 무엇인가요?

---

- 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어

#### 운영체제의 역할은 무엇인가요?

---

- 프로세스 관리

프로세스,스레드,스케쥴링,동기화,IPC통신(프로세스 간 공유 자원 접근과 통신)

- 저장장치 관리

메모리 관리, 가상 메모리, 파일 시스템

- 네트워킹

TCP/IP, 기타 프로토콜

- 사용자 관리

계정관리, 접근권한 관리

- 디바이스 드라이버

순차접근 장치, 임의접근 장치, 네트워크 장치

### 인터럽트가 무엇인지 설명해주세요

---

- 프로그램이 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것

- 지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산)이 발생하면 그 일을 먼저 처리하고 끝나면 하던 일을 계속한다.

#### HW/SW 인터럽트에 대해 설명해주세요

---

**하드웨어 인터럽트**

- 하드웨어 장치에서 발생하는 인터럽트

**예시**

키보드에서 키를 누르거나 마우스를 움직이는 등의 작업 / Timer Interrupt 가 존재

**동작**

CPU에게 전달되고, CPU는 현재 실행 중인 작업을 잠시 중단하고 인터럽트 처리 루틴(ISR)을 실행

인터럽트 처리 완료 후 다시 CPU는 작업을 재개

**소프트웨어 인터럽트**

프로그램에서 명령어를 통해 발생시키는 인터럽트

**예시**

시스템 콜(System Call), Trap

**동작**

현재 작업을 일시 중단하고, 커널 모드로 전환하여 요청된 작업을 처리한 후, 다시 유저모드로 복귀

#### 인터럽트 벡터가 무엇인가요?

---

- 인터럽트가 가진 처리 루틴 주소에 대한 포인터

#### 인터럽트 루틴이 무엇인가요?

---

- 인터럽트를 처리하는 커널 함수
- Interrupt Service Routine / 인터럽트 핸들러 라고도 한다.

#### 인터럽트는 어떻게 처리하나요?

---

![](https://velog.velcdn.com/images/sujipark2009/post/decbf5b9-edbd-4a3c-a88b-f3954cd47209/image.png)

1. 인터럽트 발생
2. 현재 실행중인 코드 완료
3. 진행중이던 상태를 해당 process의 PCB에 저장
4. 인터럽트 벡터를 읽고 ISR 주소값을 얻어서 점프
5. 루틴 실행
6. 작업 완료 후 이전 상태 복원

#### Polling 방식에 대해 설명해주세요.

---

#### Polling이 아니라면 어떤 방식을 사용하나요?

---

### 커널이란 무엇인가요?

---

- 운영체제는 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고
  그렇지 않은 부분은 필요할 때 메모리에 올려서 사용

메모리에 상주하는 운영체제의 부분을 커널이라고 한다

**역할**

- 하드웨어와 프로그램 사이에서 인터페이스를 제공하는 역할
- 컴퓨터 자원들을 관리하는 역할

#### 마이크로 커널이 무엇인가요?

---

- 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램을 구현하여 운영체제를 구성하는 방법

**장점**

운영체제의 확장이 쉽고, 새로운 서비스는 사용자 공간에 추가되기에 커널의 변경이 적음

커널이 아닌 사용자 프로그램을 사용하여 안전

반대의 경우를 **모놀리식 커널**이라고 한다

#### 커널 주소 공간에 대해 설명해 주세요

---

![](https://velog.velcdn.com/images/sujipark2009/post/d9a10e14-412d-4ca1-ad3c-2b20278a63dc/image.png)

`Code` :

- CPU,메모리 등의 효율적으로 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분

`Data` :

- 각종 자원을 관리하기 위한 자료 구조가 저장
- CPU나 메모리 같은 하드웨어 자원을 관리하기 위한 자료구조뿐 아니라 프로세스를 관리하기 위한 자료구조

**PCB**에 각 프로세스의 상태,CPU 사용 정보,메모리 사용 정보등을 유지

`Stack` :

- 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다.

시스템 콜이나 인터럽트 등으로 운영 체제의 코드가 실행되는 중에 함수 호출이 발생할 경우 커널 스택을 사용

#### 커널 스택이란 무엇인가요?

---

- 각 프로세스 또는 스레드마다 유지하는 스택(Stack)

- 커널모드에서 실행되는 코드와 관련된 데이터를 저장하는데 사용

**위치**

- 메인 메모리의 커널 영역에 존재

사용자 모드와 대비가 되며, 운영체제는 영역을 따로 할당받는다.

**사용**

- 인터럽트, 예외 처리, 시스템 호출 등과 같은 커널의 중요한 동작을 수행할 때 사용

- 커널 모드로 전환될 때, 현재 실행 중인 프로세스나 스레드의 사용자 스택과는 별개로 커널 스택이 사용

**역할**

커널의 실행에 필요한 임시 데이터, 인터럽트 및 예외처리를 위한 데이터, 시스템 호출의 인자 및 반환 값 등을 저장

#### I/O Bound 프로세스와 CPU Bound Process란 무엇인가요?

---

**I/O Bound 프로세스**

- I/O 작업에 많은 시간을 소비하는 프로세스

- 주로 입출력 작업이 빈번하게 발생하거나, I/O 장치와의 상호작용이 많은 작업을 수행(파일 읽기/쓰기,네트워크 통신, 데이터베이스 엑세스)

- CPU 자원은 비교적 유후 상태

**CPU Bound 프로세스**

- CPU 연산에 많은 시간을 소비하는 프로세스
- 계산 집약적인 작업이나 알고리즘 실행,수학적 연산을 수행

#### I/O 장치가 작업을 완료하면 어떤 일이 일어나나요?

---

1. I/O 장치는 작업이 완료되면 CPU에게 인터럽트 신호 발생

2. CPU는 I/O 장치의 인터럽트를 처리하기 위해 인터럽트 핸들러로 제어를 전달

인터럽트 핸들러는 해당 I/O 장치와 관련된 작업을 처리

3. 인터럽트 서비스 루틴(ISR) 실행

인터럽트 핸들러는 인터럽트 서비스 루틴(Interrupt Service Routine)을 실행

ISR은 I/O 장치의 작업을 완료하기 위해 필요한 추가 작업을 수행

주로 작업 완료 상태를 확인하고, 결과를 처리하거나 다음 동작을 위한 설정

4. 작업 결과 처리

- ISR은 I/O 작업 결과를 확인하고 이를 적절하게 처리
- 데이터를 메모리로 전송한 경우에는, 데이터를 메모리에 저장

인터럽트를 발생시킨 프로세스 또는 스레드로 작업 완료를 알림

- I/O 장치의 상태 변경을 처리하기 위해 작업 등을 수행

5. 제어의 반환

- ISR이 작업을 완료하면, CPU는 해당 프로세스 또는 스레드의 실행을 계속 진행하도록 제어를 반환

- 프로세스 또는 스레드는 I/O 작업의 완료 상태를 확인하고, 필요한 후속 작업을 수행
