#### 배경지식

라우터에 패킷이 들어오면, 라우터의 버퍼(큐)에 들어가게 되는데

큐 안에 공간이 가득 찬 상황에서 패킷이 오면, 어쩔 수 없이 DROP될 수 밖에 없고 그것이 바로 `packet loss` 이다.

지금부터 한단계 더 아래에 있는 Network 계층에 대해 이야기해보자.

네트워크는 복잡한 시스템이기 때문에 이것을 잘 관리하기위한 목적으로 하위계층으로 갈수록 디테일하게 계층화를 시켜놓았다.

이제 TCP Segment를 목표지점까지 **어떻게 보낼까** 를 이야기해보자.

우선, 그걸 가능하게해주는 3계층의 프로토콜이 바로 **`IP(Internet Protocol)`** 이다.

라우터가 패킷을 목표지점까지 보내는 역할을 하기 때문에, 라우터는 3계층까지의 계층 스택을 가지고 있을 것이다.

Network layer가 하는 일은, Source에서 Destination까지 어떻게 패킷을 잘 보내느냐 이다.

라우터에서 패킷을 받으면, 헤더를 분석해서 어디로 가야할지, 에러는 없었는지를 분석하게 되고 사실 그러한 작업의 연속이다.

좀 더 생각해보면 라우터는 `Forwarding`과 `routing`을 하는데

패킷의 헤더를 보고 해당 패킷을 특정 방향으로 전달해야한다.

그러기 위해서는, 패킷의 목적지가 어디고, 어디로 보내야할지를 알아야 한다.

라우터 안에는 `Routing Table` 이라는게 존재하는데 라우터는 패킷의 목적지를 보고 -> 테이블을 보고 -> 해당 방향으로 보내는 역할을 한다.

**들어온 패킷의 목적지 주소와 Table의 Entry를 매칭시켜서 알맞은 곳으로 보낸다는 것이다**

그런데 여기서 의문점은, 이 `Forwarding Table`은 누가 어떻게 만드냐는 것이다.

아마 사람이 만들지는 않을거고..

자동적으로 생성되어야 하는데, 그게 바로 `Routing Algorithm`이 해주는 일이다.

그럼 Forwarding 테이블의 Entry는 <목적지 주소, 목적지 주소에 해당하는 인터페이스> 이런식으로 되어있을까?

그러면 너무 많겠지?

그래서 주소 범위로 Forwarding Table이 관리되어진다.

![](https://velog.velcdn.com/images/sujipark2009/post/42d1882c-1b16-4e5e-b671-95f746ae17a4/image.png)

주소범위 어디부터 어디까지는 몇번으로 나가세요~ 이런식으로 되어있다.

![](https://velog.velcdn.com/images/sujipark2009/post/64e253ad-2987-4016-acf4-60cdb48f5fea/image.png)

이런식.

![](https://velog.velcdn.com/images/sujipark2009/post/8c207c41-3ead-46ad-a741-6b9a81e2d88c/image.png)

IP헤더를 보면, 되게 뭔가 많은데.. 이것들은 잘 알아야 한다.

ver은 IP의 version을 나타내는데 주로 IPv4로 되어있음

Source IP Address,Dest IP Address 이 2가지가 가장 중요하다.

Time to live은 네트워크에서 이 패킷이 살아있을 수 있는 시간을 의미하며, 라우터를 거칠때마다 숫자가 -1씩 줄어든다.

이 필드가 필요한 이유는, 만약 TTL이 없다면 네트워크상에서 계속 루프를 돌 수 있기 때문에 네트워크 오버헤드가 될 수 있기 때문이다.

Upper Layer : Payload(DATA)부분에 들어가는게 TCP인지 UDP인지를 명시하기 위한 필드

Receiver측에서 이 정보를 가지고 TCP로 올릴지 UDP로 올릴지 결정할때 사용한다.

참고로 IP헤더의 크기는 20B고 TCP헤더도 20B라고 함.

인터넷의 패킷을 까보면 상당수의 패킷이 40B짜리인데, 이게 다 `TCP ACK` 라고 한다.

#### IP Address(IPv4)

---

IP는 32bit 주소체계를 가지고, 따라서 이론상 2^32개의 IP주소를 가질 수 있다.

그런데 이게 사람이 읽기 어려우니까.. 읽기좋게 8bit씩 끊어서 십진수로 바꾼게 우리가 평소에 읽는 방식이다.

그래서 8bit씩 끊으니, 255가 최대일것이고, 255.255.255.255 이런식으로 될 것임.

이 IP주소는 결국 무엇을 지칭하는 주소체계냐면, 호스트에 들어있는 네트워크 인터페이스(NIC) 자체를 의미한다.

컴퓨터의 인터페이스(Network Interface Card)를 지칭한다는건데,

컴퓨터에 NIC를 여러개 꼽으면 IP를 여러개 가질 수 있다는 것이다.

이런 특수한 컴퓨터의 예시가 바로 `라우터` 이다.

IP는 인터페이스 자체를 지칭하는 주소라고 했는데, 그럼 이러한 IP주소는 어떻게 배정이 되었을까?

단순하게 하는 방법은 아무렇게나 배정하는 것인데, 그렇게하면 호스트 별로 라우터에서 나가야하는 방향이 다 다를거니까 Forwarding 테이블이 엄청 커지게된다.

![](https://velog.velcdn.com/images/sujipark2009/post/2d1d6d66-bf34-470c-86f5-35df8801c3ee/image.png)

1.2.3.4 는 <= / 1.2.3.5 는 =>

이런식으로 싹~다 표현하면 너무 많으니까.. 그래서 이것도 계층화를 시켜놓았다.

![](https://velog.velcdn.com/images/sujipark2009/post/3da4262f-a557-46ed-a452-4034bef03f29/image.png)

앞부분은 `Network ID`, 뒷부분은 Network에 속한 host를 지칭하는 `Host ID`로 정의해놓았다.

위의 사진을 보면, 앞의 24bit가 Network ID이고 뒤의 8bit가 Host ID가 된다.

근데.. 이렇게 하면 알아보기 어려우니까 어디까지가 네트워크의 ID인지를 표현한게 바로 `Subnet Mask` 이다.

255.255.255.0 이면 앞의 24bit가 네트워크의 주소라는 의미.

![](https://velog.velcdn.com/images/sujipark2009/post/30512c2f-0c33-4ba8-931b-de83aeb9c10a/image.png)

1.2.3.0/24 라는 말은, 24bit가 네트워크의 주소를 나타내고 나머지 8bit로 호스트 주소를 나타낸다는걸 의미한다.

이런식으로 구성해놓으면 같은 네트워크에 속한 것들은 같은 IP Prefix를 가진 IP Address를 가지게 되고, Forwarding table을 좀 더 단순하게 표현할 수 있게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/83804379-3078-4375-9740-81f21da28ed5/image.png)

새로운 호스트를 추가하더라도 테이블의 변화 없이 내 마음대로 같은 Prefix를 줘서 추가할 수 있게 된다.

여기서 잠시 용어를 정리하면, Network ID = Subnet ID = Prefix 다 같은말이다.

...

과거에는 IP주소가 어떻게 배분되었을까?

인터넷이라는 것은, 네트워크의 집합인데 즉, 네트워크의 네트워크라는 말이다.

그러면 결국 그 네트워크들은 자기자신들의 Prefix를 가져야하고 그 크기는 다 다를것이다.

예전에는 네트워크에게 Prefix를 배정할때 `Class`라는 개념을 두고 배정을 했었는데

Class A,B,C 이런식으로 했었다.

class A에 해당하는 주소는 /8으로,

- class A는 맨 앞이 0으로 시작해야한다.(00000000 ~ 01111111)
- 이 경우, 호스트 ID는 24bit이므로 2^24개를 가질 수 있다
- 그럼 이 class A를 가질 수 있는 기관은 전세계에 몇 개 없을것이다.
- 왜냐하면.. 2^7개의 기관만이 class A를 가질거니까.

class B는 /16으로

- 2^16개의 호스트를 가질 수 있다

class C는 /24으로

- 2^8개의 호스트를 가질 수 있다.

그럼 A가 가장 많은 호스트를 가질 수 있으니 이게 가장 좋을까?
그런데.. MIT / IBM 이런 선구자들만 가질 수 있겠지?
C는 또 엄청 많은 기관이 가질 수 있으나, 2^8개 밖에 호스트를 가질 수 없다.

너무나 비효율적임을 알 수 있다. 어느것은 너무 크고, 어느것은 너무 적다.

이것을 위해 나온게 `Classless Inter-Domain Routing(CIDR)` 이다.

![](https://velog.velcdn.com/images/sujipark2009/post/4e8b4d0a-17fd-4e76-bac8-2a4d0e181c5f/image.png)

8개씩 끊는게 아니라, 12.4.0.0/15 이런식으로 사용할 수 있다는 것이다.

만약 호스트가 1000개 필요하다? 대충 2^10이니 10bit만 할당해주면 되니까

/22 를 사용하면 된다.

예시를 들어보자.

201.10.6.17 이라는 IP주소가 라우터에 들어왔다고 해보자.

라우터가 하는 일은, 패킷을 받아서 Destination IP에 매칭되는 Entry를 찾는 것이라고 했다.

Entry중 하나가 201.10.0.0/21 의 경우,

201.10.00000 | 000

이렇게 해서 앞이 네트워크 부분, 뒤가 호스트 부분인데 해당 Entry에 방금 들어온 IP가 매칭이 된다.

201.10.6.17 = (201.10.00000110.00010001) 이렇게 표현이 되고 네트워크 PREFIX가 같으니까 매칭이 된다.

근데 다른 Entry인 201.10.6.0/23을 보면,

이건 201.10.0000011 | 0 이런식으로 나눠지는데, 이 Entry에도 위의 IP가 매칭이 된다.

그럼 둘 중 어느것에 매칭이 될까?

이 중 **가장 구체적으로 매칭되는 Entry** 를 찾아야 한다.
이 중 `Prefix가 가장 긴 것` 을 찾아서 매칭시켜주면 되는 것이다.

당연한게, Prefix가 긴 곳을 가야 거기안에 호스트 수가 적으니까 빨리 찾겠지?

정리하면, IP주소는 32bit를 사용하는데 Prefix / HOST 부분으로 나뉘어져 있다는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/f7fc3286-496d-4229-8c43-c4ae3c27af50/image.png)

Subnet이라는건, 같은 Prefix를 가진 디바이스들의 집합이다.

Prefix를 다른말로 하면 `라우터를 거치지 않고 도달가능한 호스트들의 집합` 이다.

라우터는 IP주소를 가질까? => 당연히 가진다.

아까 NIC를 가지니까 IP주소를 가진다고했고 오히려 NIC개수만큼 IP를 가질 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/e5478ab6-7bd9-4005-aae0-5b3ddf9fc47e/image.png)

이 그림에서 각 라우터는 IP를 3개를 가지고 있다(/24라고 한다면)

이 말은, 라우터는 3개의 서브넷에 속해있다는 말이다.

이 그림상에서 서브넷은 총 `6개` 이다.

...

IPv4는 32bit이고 이론상 2^32개의 호스트를 지원가능하다고 했다.

2^32는 한 40억정도 되는데,

근데 이제 인터넷이 상업화가 되면서 주소공간이 고갈될수도 있겠다는 결론이 나왔다.
그래서 95년부터 디자인 한 것이 IPv6인데 이것은 128bit를 기반으로 한다.
근데 현재 우리는 여전이 IPv4를 사용하고 있다.
어떻게 하는걸까? 예측을 잘못했었거나, 어떤 `트릭` 을 쓰거나겠지?
한집에 기기가 몇개인데.. 이미 40억개를 넘은지는 오래일거고.. 그럼 어떤 트릭을 사용했을까?

**뭔가 공유를 하고 있다는 것이다**

그 트릭이 바로 `Network Address Translation` 이다.

NAT를 보면,

![](https://velog.velcdn.com/images/sujipark2009/post/e8891424-8616-4fd3-a89d-fdf99c716a49/image.png)

네트워크 내부에서는 유일한 네트워크 주소를 사용하는데 이런 IP주소를 가진 패킷이 외부로 나갈 때는, 유일한 패킷 주소로 바뀌어야 한다.

받는 사람측에서는 "아~ 저 라우터에서 왔구나?" 라고 생각할 수 있게 말이다.
이것이 바로 NAT의 동작이다.

구체적으로 보면,

![](https://velog.velcdn.com/images/sujipark2009/post/e7b89469-3a1c-4325-80cf-b70a2cac7f1f/image.png)

내부적으로 유일한 네트워크 주소에서 외부로 패킷을 보내는데

이 패킷은 그대로 나가면 안된다.(왜냐하면, 이 네트워크 안에서만 유일한 IP주소이므로)

그래서, 라우터에서 Source 주소를 라우터의 주소로 변환하고 또 **Port 번호도 바꾼다**

**Q. Port번호는 왜 바꾸냐?**

원래 그림에서, 10.0.0.1,3345포트 였는데 나갈때는 왜 138.76.29.7,5001포트로 변환했을까?

내부에서 만약 같은 3345번을 사용하는 다른 호스트도 있다고 한다면?

패킷이 나갔다가 들어올 때에는, 결국 포트번호로 목적지를 찾게 되는데 내부 네트워크에 있는 호스트들의 포트번호가 같으면 어디로 가야할지를 알 수가 없으니까 애초에 나갈때부터 포트를 바꿔서 나가게 된다.

(만약, 10.0.0.1 3345에서 나가고 10.0.0.2 3345에서도 나간다면, 포트를 안바꾸고 나갈경우 라우터에 (138.76.29.7 <-> 10.0.0.1,3345),(138.76.29.7 <-> 10.0.0.2,3345) 이렇게 기록이 될 것이다.

근데 나갔다가 들어올때 둘 다 포트가 같으면 어디로 가야할지를 모르기때문에 포트번호도 바꿔서 나가는 것)

그런데 이렇게 NAT를 하면 IP주소를 재사용 할 수 있긴 한데, 문제가 있다.

IP Packet에는 헤더와 데이터가 있는데, 라우터에서 패킷이 나갈 때 헤더에 있는 Source IP를 변경했고 데이터 부분에 있는 TCP의 Port번호까지 지금 바꾼 상황이다.

Network layer 장치인 라우터는 네트워크의 헤더만 봐야하는데 지금 상위 계층(4계층)의 DATA 내용을 까서 Port번호까지 바꾼 상황인 것이다.

이게 바로 `Layer Violation` 이다.

근데 이것만 문제냐?

원래 IP주소는 호스트 인터페이스를 찾아가기 위한 것이고, Port 번호의 기능은 호스트를 찾아가서 `프로세스` 를 찾아갈 때 쓰는건데

지금 패킷이 외부에서 들어와서, 저 포트번호 5001을 어떻게 쓰고있냐면

내부 네트워크의 `호스트` 를 식별하는데에 쓰고있다.

**Q. NAT를 사용하는 네트워크 내부에서 서버를 운용할 수 있을까?**

내가 80번 포트를 열고 웹 서버를 운영하고 싶은데, 가능할까?

남들이 아~무리 80번 포트로 보내봤자 그건 호스트에 도달할 수가 없다..

왜냐하면, NAT는 기본적으로 `내부 네트워크의 IP주소와 포트를 외부에 숨기기 위해 설계된 기술` 이다.

외부에서 들어오는 요청이 있을 때, NAT 장치는 이 요청을 어디로 보낼지 결정해야 하는데, 문제는 NAT가 외부에서 내부로 들어오는 트래픽을 처리할 방법이 제한적이라는 것이다.

NAT는 내부에서 외부로 나가는 요청에 대해서만 매핑 테이블을 생성하게 되고 응답이 들어올 때 이 매핑 테이블을 보고 원래의 내부 IP와 포트로 다시 매핑하게 된다.

반면, 외부에서 내부로 직접 들어오는 요청에 대해서는 미리 설정된 매핑 테이블이 없기 때문에 어떻게 처리할지 모르는 상황이 생기게 되고, NAT입장에서는 외부 요청이 들어와도 그 요청을 내부 서버에다가 연결해줄 방법이 없는것이다.

이를 해결하려면 **포트 포워딩** 이라는 기능을 사용해야하는데, 이는 NAT 장치에 특정 포트가 들어오면 내부의 어느 IP와 포트로 연결할지를 미리 설정해두는 방식이다.

예를들어 공인 IP의 80번 포트로 들어오는 요청은 10.0.0.1:80에 전달하도록 설정할 수 있다는 것.

하지만 이 기능은 NAT 장치에서 일일이 설정해야 하므로 수동으로 설정해야한다.

한마디 요약하면, **안에서 요청이 나가기 전에는 외부에서 못들어온다**는 것이다.

내부에서 요청이 안나가면 매핑 테이블이 생성되지 않기 때문에 내부에서 서버를 열고있어도 외부에서 접근이 불가능하다.

#### IP 주소는 무엇이며, 어떤 기능을 하고 있나요?

---

- 네트워크에 연결된 통신 기기들을 식별하기 위한 주소.
- 통신 기기마다 고유하게 할당되어 있지 않고 가변적임.
- HOST를 식별하기 위한 목적으로 사용

#### IPv4와 IPv6의 차이에 대해 설명해주세요.

---

![](https://velog.velcdn.com/images/sujipark2009/post/349955f1-33e8-472c-9a46-7ca741cb4a8d/image.png)

IPv4는, 32bit 주소체계를 갖는 네트워크 계층 프로토콜이다.

- `.` 으로 구분된 4개의 `옥텟` 으로 구성된다.
  각각 0~255 범위를 나타내며 총 43억개의 주소가 가능하다.

![](https://velog.velcdn.com/images/sujipark2009/post/9051a545-8ca8-464a-8974-ed3863a2aaf2/image.png)

- Network Part와 Host Part로 구분되어 있다.

IPv6는, 128bit 주소체계를 갖는 네트워크 계층 프로토콜이다.

- 16bit씩 8자리로 구성되어있으며 `:` 으로 구분한다.

- 확장 헤더를 사용하여 IPv4보다 훨씬 다양하고 안정된 옵션 사용이 가능하다.
- 라우터 부담을 줄이고 네트워크 부하 분산
- 보안,인증,라벨링,데이터 무결성,데이터 비밀성 제공
- NAT가 더이상 필요하지 않음

#### IPv4를 사용하는 장비와 IPv6를 사용하는 장비가 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?

---

- IPv4와 IPv6는 서로 호환되지 않는 프로토콜로, 기본적으로 IPv4를 사용하는 장비는 IPv6를 사용하는 장비와 직접 통신할 수 없다.

3가지 방법이 있는데,

1. **듀얼 스택(Dual Stack)**

![](https://velog.velcdn.com/images/sujipark2009/post/a92a2fcc-746b-469f-8e63-8393fb5d18d8/image.png)

- 장비에 IPv4와 IPv6의 두 가지 스택을 모두 구현하는 것
- 장비는 동시에 IPv4와 IPv6 주소를 갖게 되며, 이를 통해 IPv4와 IPv6 네트워크와 모두 통신
- 듀얼 스택이 활성화 된 IP Node는 IPv4,IPv6 주소를 동시에 가지게 된다.

2. **터널링(Tunneling)**

![](https://velog.velcdn.com/images/sujipark2009/post/2a18dc31-fd96-4dff-b06c-0501c2e529d0/image.png)

- IPv4 네트워크를 통해 IPv6 패킷을 "캡슐화" 하여 전송
- IPv4 네트워크가 IPv6 통신을 지원하지 않을때 사용

- 두 개의 IPv6 호스트 사이에 IPv4 망이 존재할 경우에, IPv6 패킷을 IPv4 패킷에 "캡슐화" 하여 사용하는 기술이다. IPv4를 통과한 패킷은 다시 디캡슐화 되어 IPv6패킷으로 정상적 통신을 하게 된다.

3. **변환(Address / header Translation)**

- IPv4와 IPv6 패킷 사이에서 직접 변환을 수행
- NAT64와 같은 기술

- 주소 및 헤더 변환 기술은 IPv4망과 IPv6망 사이에 주소 변환기를 사용하여 기존에 IPv4에서 사용되던 NAT기술과 마찬가지로 IPv6와 IPv4 간의 Address Table을 생성하여 양단간의 통신이 가능하도록 상호 연동 시키는 기술이다.

#### IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?

---

- IPv6를 이용하는것이 가장 근본적인 해결책이다.

128bit의 주소를 제공하므로, 이론적으로는 거의 무한한 수의 고유한 IP주소

- 단, IPv6는 기존의 IPv4 인프라와 호환되지 않는 문제가 있다.

신규 HW,SW,네트워크 관리 시스템의 도입이 필요하고, 이것에는 큰 비용과 시간이 든다.

- NAT : IP주소를 재사용하는 방식이다.

- CIDR(Classless Inter-Domain Routing) :  
  네트워크 클래스의 제한을 제거하고 어떤 IP주소도 어떤 크기의 네트워크에 할당할 수 있게 함

#### IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?

---

공통점은 둘 다 오류 검출을 수행한다는 것이다.

차이점은,

계산하는 체크섬의 범위와 목적인데,

IPv4 Checksum은,

- IPv4 패킷 헤더 내의 정보가 전송 중에 오류없이 도착했는지를 확인한다(헤더 무결성).

- 패킷의 Payload(데이터)에 대해서는 계산되지 않는다.
- 매 홉에서 라우터에 의해 재계산 된다.
- 패킷의 일부 필드(예 : TTL)가 각 라우터에서 변경되기 때문이다.

TCP Checksum 은,

- 전체 TCP 세그먼트의 무결성을 위해 TCP 세그먼트 전체(헤더와 페이로드 모두)에 대해 계산한다.

오류가 발생하지 않았는지 확인한다.

- 패킷이 출발지에서 목적지까지 전송되는 전체 과정에서 오류를 검출

- 송신측에서 계산되고 수신측에서 검증(데이터의 무결성을 보장하게 위해)

#### TTL(Hop Limit)이란 무엇인가요?

---

TTL(Time to Live) 또는 Hop Limit은 데이터 패킷이 네트워크에서 존재할 수 있는 최대 시간이나 "홉" 수를 지정하는 필드

- "홉" 은 패킷이 통과하는 중간장치(라우터 등)를 의미

- IPv4에서는 이 필드가 TTL로, IPv6에서는 Hop Limit으로 불림

- 잘못된 라우팅이나 라우팅 루프로 인해 패킷이 무한히 순환하는 것을 방지한다.

작동방식을 보면,

- 송신자가 패킷을 보낼 때 TTL값을 설정

운영체제에 따라 다르며, 일반적으로 초기값은 64,128,255

- 패킷이 라우터를 통과할 때마다 라우터는 TTL 값을 1씩 감소

- 만약 TTL값이 0이 되면, 라우터는 패킷을 더 이상 전송하지 않고 버린다.
  라우터는 패킷의 원본 송신자에게 패킷이 폐기되었음을 알리는 `ICMP` 메시지를 보낸다.

#### 서브넷 마스크에 대해 설명해주세요

---

서브넷 마스크는, IP를 네트워크 주소와 호스트 주소의 두 부분으로 나눈다.

특정 네트워크에 속한 호스트를 식별하는데 도움을 준다.

방식은,

이진수로 표현해서 모두 1인경우 네트워크 주소 / 모두 0인경우 호스트 주소를 나타낸다.

예를들어, 서브넷 마스크가 255.255.255.0 이면

11111111.11111111.11111111.00000000

첫 3개의 옥텟은 네트워크 주소, 마지막 옥텟은 호스트 주소를 의미한다.

#### 서브넷팅이란 무엇인가요?

---

네트워크를 더욱 작은 단위의 네트워크로 분할하는 것

- IP주소의 낭비 방지

- 브로드캐스트 도메인의 크기를 줄여서 성능 향상
- 회사 층별 서브넷팅

서브네팅이란, 간단하게 말하자면 IP주소를 효율적으로 나누어 사용하기 위한 방법을 일컫는다.

네트워크 성능 보장, 자원을 효율적으로 분배하기 위해 네트워크 영역과 호스트 영역을 `쪼개는 작업` 을 행한다.

서브넷팅을 하면 IP 할당 범위를 더 작은 단위로 나눌 수 있게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/06c462d4-2700-4586-b6ca-548c6b47a1bd/image.png)

만일 호스트를 50개만 사용하는 기업이 192.168.10.0/24 아이피 주소를 사용한다고 가정하면, C클래스이니까 2^8(256)개의 주소를 할당하게 되는데,

256개 전체를 주기에는 낭비가 되니까.. 이 256개를 절반으로 나누고 또 절반으로 나눈 주소를 기업에게 할당하고 남는 네트워크 주소는 다른 사용처로 할당하는 효율적인 작업이 바로 서브네팅 원리이다.

다시,

100개의 아이피를 사용하는 회사가 있다고 가정하자.
이 회사에게 아이피 대역을 할당할 예정이다.

100개 밖에 사용안하니 가장 작은 C클래스 대역을 줄 예정인데(192.168.10.0/24) 그래도 256개를 전부 주기에는 낭비가 있어 보인다.

/24 라는 뜻은 1이 24개라는 뜻이다.
그러면 24비트까지가 네트워크 ID,25번째 부터는 호스트 ID가 된다.

11000000.10101000.00001010.00000000

호스트 ID가 8비트니까 할당가능한 호스트 갯수는 256개가 된다.

하지만 100개만 쓴다고하니.. 이걸 다 주는것은 낭비이다. 256개를 절반으로 나누는 작업을 시행해보자.

![](https://velog.velcdn.com/images/sujipark2009/post/67cfa7b2-696e-4e01-9940-c3c6433b8ebb/image.png)

128개씩 두개로 나누기 위해 **서브넷 구분 비트** 라는 것을 지정해주어야 한다.

서브넷 구분 비트는 이름 그대로 **네트워크 주소를 어느 기준으로 쪼개서** 서브넷(분할된 네트워크)을 만들어 구분할지 정하는 비트라 이해하면 된다.

서브넷 구분 비트는 **항상 호스트 ID에서 왼쪽부터 결정**이 되어야 한다는 특징이 있다.

즉, 호스트 ID의 맨 왼쪽을 서브넷 구분 비트로 지정하게 되면, 0과 1로 구분되어지는데 범위가 2진수로 다음과 같이 나뉘게 된다.

.00000000~.01111111(0~127)
.10000000~.11111111(128~255)

즉, 호스트 ID 맨 왼쪽 비트가 0이냐 1이냐에 따라 서브넷이 두개로 분리되게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/e16bf2dd-f50d-442a-b618-9436e4f40b0e/image.png)

이렇게 절반으로 나눈 한 서브넷 부분을 이제 회사에게 할당하고 나머지도 필요한 곳에 분배하면 된다.

이때, 어느 한 네트워크 범위의 가장 첫번째 주소(0)과 마지막 주소는 네트워크 / 브로드캐스트 주소로서 제외해야함에 주의한다.

![](https://velog.velcdn.com/images/sujipark2009/post/a19b5a97-acbc-4297-9cee-7f76b2860eba/image.png)

따라서 사용가능한 호스트는
192.168.10.1 ~ 192.168.10.126
192.168.10.129~192.168.10.254

가 된다.

**주소범위를 4등분 나누기**

이제 50개의 호스트만 사용하는 회사가 있다고 하면,

128도 많으니 이걸 또 반으로 쪼개야한다.

4등분 하기위해 **서브넷 구분 비트**를 **왼쪽에서 2비트**로 지정한다.

![](https://velog.velcdn.com/images/sujipark2009/post/02db9aed-930d-4344-bee0-20ce445f05bc/image.png)

그러면 서브넷 구분 비트는 00,01,10,11 로 총 4개로 구분되어질 수 있고

00000000~00111111
01000000~01111111
10000000~10111111
11000000~11111111

로 범위가 4등분되어 나뉘어 줄 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/f1650977-33c8-4f0e-a0fe-40614ee7968e/image.png)

#### 서브넷 마스크의 표현 방식에 대해 설명해주세요.

---

- 네트워크 주소의 경우 HOST Part가 모두 0

- 브로드캐스트 주소의 경우 HOST Part가 모두 1

- 위의 두 주소를 제외한 나머지만 할당가능하다.

#### 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?

---

서브넷 마스크를 좀 더 엄격히 말하면, 1이 연속해서 있는 그룹이 서브넷 마스크이다.

### MAC주소와 IP주소의 차이를 설명해주세요

---

MAC주소는, NIC(Network Interface Card)에 할당된 고유한 주소이다.

이는 제조단계에서 할당되는 정보이다.

IP주소는, 네트워크에서 장치의 위치를 나타내기 위한 논리적 주소로 동적으로 변하는 주소이다.

#### Host는 MAC주소와 IP주소를 어떻게 이용하나요?

---

MAC주소는 물리적으로 연결된 네트워크에서 사용

- 로컬 네트워크에서 호스트 간 통신에 사용

IP주소는 논리적인 주소로서 인터넷상에서 호스트들이 서로 통신할 때 사용

- 호스트가 다른 호스트에게 데이터를 보내고자 할 때
  출발지 IP주소와 목적지 IP주소를 데이터에 포함시켜 패킷(Packet)을 만든다.

- ARP(Address Resolution Protocol) 프로콜을 사용항여 호스트의 IP주소를 기반으로 MAC주소를 찾아내는 등의 기능을 수행

#### ARP에 대해 설명해 주세요.

---

Address Resolution Protocol

- 네트워크 상에서 IP 주소와 해당 IP 주소에 해당하는 물리적인 MAC주소를 매핑하는 프로토콜

- 3계층이라고 많이 하지만, 2.5계층이라는 입장도 있음

- 데이터 링크 계층(예: 이더넷)에서 물리적 주소와 인터넷 계층(예: IP)에서의 논리적 주소를 연결하는 역할

**동작과정**

컴퓨터 A가 컴퓨터 B에게 데이터를 전송하려는 상황

A는 B의 IP주소를 알고있지만, MAC주소는 모른다.

- 컴퓨터 A는 ARP 요청 패킷을 로컬 네트워크 상의 모든 기기들에게 브로드캐스트
  브로드캐스트를 통해 컴퓨터 B가 자신의 IP주소와 일치하는 ARP 요청을 받는다.

- 컴퓨터 B는 ARP 응답 패킷을 생성한다
  컴퓨터 B의 IP와 MAC주소가 포함되어있다.

- 컴퓨터 B는 ARP 응답 패킷을 컴퓨터 A에게 유니캐스트로 전송

- 컴퓨터 A는 받은 ARP 응답 패킷에서 컴퓨터 B의 MAC주소를 추출
  ARP 캐시에 저장하고 MAC주소를 이용하여 데이터 패킷을 B에게 전송한다.

#### 게이트웨이에 대해 설명해주세요

---

게이트웨이란, 네트워크가 다른 네트워크와 통신하기 위한 접점이다.
일반적으로 라우터를 가리킨다.

- 특정 네트워크에 연결된 호스트가 외부 네트워크나 인터넷에 접근할 때 사용하는 IP주소를 나타낸다.

- 패킷을 올바른 목적지로 라우팅 한다.
  호스트가 외부 네트워크에 있는 호스트와 통신하려면, 패킷은 이 게이트웨이를 통해 전송이 된다.

- 집이나 사무실의 로컬 네트워크에서 게이트웨이는 보통 브로드밴드 라우터의 IP주소

#### Private IP와 Public IP에 대해 설명하세요

---

Private IP는, 가정 및 사내에서 공유기에 의해 할당되는 주소이다.

로컬 IP,사설 IP라고도 한다.

- IPv4의 주소부족으로 인해 서브넷팅된 IP

Public IP는, ISP에서 할당하여 전 세계에서 유일한 IP주소

- 다른 PC에서 접근이 가능
- Private IP외 나머지 범위 사용

#### NAT에 대해 설명해 주세요.

---

Network Address Translation

사설 IP주소를 공인 IP주소로 변환하거나 그 반대의 변환을 수행하는 기술

- 주로 라우터에 적용
- 하나 또는 일부의 공인 IP 주소를 이용해 네트워크 내의 여러 장치가 인터넷에 접속할 수 있도록 함

**SNAT(Source NAT)**

출발지 IP주소를 변환하는 방식

- 일반적으로 사설 네트워크에서 인터넷으로 나가는 트래픽에 사용하ㅏㄴ다
  내부 네트워크의 사설 IP주소는 공인 IP주소로 변환되며, 인터넷에 도착하는 응답은 다시 사설 IP주소로 변환

**DNAT(Destination NAT)**

목적지 IP주소를 변환하는 방식

- 일반적으로 인터넷에서 사설 네트워크로 들어오는 트래픽에 사용
  외부에서 접근하는 공인 IP주소는 내부 네트워크의 특정 사설 IP주소로 변환

**역할**

IPv4 주소 공간의 부족 문제를 완화하는데 중요한 역할

- NAT를 사용하면, 사설 네트워크의 모든 장치가 단일 공인 IP주소를 공유하여 인터넷에 접속할 수 있음

- 공인 IP 주소의 사용을 크게 줄일 수 있음

보안 측면에서도 중요한 역할

- 외부 네트워크에서는 NAT 뒤의 사설 IP주소를 직접 볼 수 없기 때문
  내부 네트워크의 장치를 외부의 공격으로부터 보호

#### ICMP란 무엇인가요?

---

Internet Control Message Protocol

인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나

네트워크 계층에서 오류 보고와 운영 정보를 전달하는데 사용

### 라우터가 무엇인가요?

---

![](https://velog.velcdn.com/images/sujipark2009/post/39510c02-f996-41bc-bef8-af02e4b4974e/image.png)

컴퓨터 네트워크 간에 패킷을 전송하는 장치

패킷을 추출하여 그 위치에 대한 최적 경로를 지정

- 이 경로를 따라 패킷을 다음 장치로 전달
- 라우팅과 포워딩

**특징**

- 게이트웨이 역할을 수행하기도 함
- 공유기가 라우터 역할을 하기도 함

**구성**

입력포트 / 출력포트

라우터의 물리 및 데이터 링크 층 기능 수행

- 프레임을 패킷으로 역캡슐화 -> 오류 탐지 -> 큐에 넣음

- 출력포트는 반대의 일 수행

라우팅 프로세서

- 목적지 주소를 사용해서 다음 홉 주소를 찾고 출력포트 번호를 결정

스위치 구조

- 패킷을 입력 큐에서 출력 큐로 이동

#### 라우터의 기능인 라우팅과 포워딩의 차이는 무엇인가요?

---

**라우팅**

- 패킷 단위로 출발지에서 목적지까지의 경로를 결정하는 것

- 해당 경로로 패킷을 이동시키기 위해 라우터가 라우팅 알고리즘을 이용하여 포워딩 테이블을 만듦

- 최단거리를 찾는 알고리즘을 사용
- 소프트웨어가 담당

**포워딩**

- 라우터의 입력포트에서 출력포트로 패킷을 이동시키는 것
- 라우터가 이미 결정된 경로(라우팅 테이블)를 기반으로 패킷을 다음 네트워크 장치로 전달하는 과정

- 하드웨어가 담당하며, 패킷이 올바른 다음 hop으로 가게 한다.

#### 라우터 내의 포워딩 과정에 대해 설명해주세요.

---

1. 패킷 수신

- 네트워크 인터페이스를 통해 들어오는 IP 패킷을 수신
- 헤더의 목적지 IP 주소를 확인
- 목적지 주소의 클래스를 알아냄 => 클래스를 통해 탐색할 테이블 결정

2. 패킷 검사

- 패킷이 유효한지 확인

Header Checksum 필드를 확인하여 헤더 오류를 검사한다

3. 라우팅 테이블 조회

- 패킷의 목적지 IP 주소를 기반으로 라우터의 라우팅 테이블을 조회
- 라우팅 테이블에는 네트워크 목적지, 다음 홉 주소, 네트워크 인터페이스 정보가 있음

- 라우터는 목적지 IP 주소와 가장 일치하는 항목(가장 긴 접두사 일치, Longest Prefix Match)을 찾아 해당 패킷을 어느 인터페이스로 보내야 할지 결정

4. 다음 홉 결정

- 라우팅 테이블 조회 결과, 패킷이 전달될 다음 홉(Next hop)의 IP 주소와 연결된 네트워크 인터페이스가 결정

- 라우팅 테이블에 일치하는 항목이 없다면, 패킷은 폐기되거나 기본 라우트(Default route)를 통해 전달

5. 패킷의 TTL(Time-To-Live)감소

- TTL은 패킷이 네트워크를 통과할 수 있는 최대 홉 수
- 패킷의 TTL 값을 1 감소
- TTL이 0이되면 라우터는 패킷을 폐기하고, 발신자에게 "TTL exceeded" 라는 ICMP 메시지를 보낸다.

6. 패킷 수정 및 재조립(필요한 경우)

- 패킷의 크키가 네트워크 MTU(Maximum Transmission Unit)를 초과할 경우, 패킷을 분할

- 라우터가 NAT(Network Address Translation)을 수행하는 경우 IP주소를 변경

7. 패킷 포워딩

- 수정된 패킷을 적절한 네트워크 인터페이스를 통해 다음 홉으로 전송

- 목적지에 도달할 때까지 다른 라우터를 거쳐 반복적으로 포워딩 과정을 거친다

ARP 모듈

- Next-Hop-Address와 인터페이스 번호를 사용하여 다음 라우터의 물리 주소를 찾음

- 다음 데이터링크 계층에 패킷을 Next-Hop으로 전달할 것을 요청

#### 목적지 주소 기반 포워딩과 레이블 기반의 포워딩에 대해 설명해주세요.

---

유기

#### 라우팅 테이블을 만드는 것고 포워딩 테이블을 만드는 것은 어떤 차이가 있나요?

---

**라우팅 테이블**

![](https://velog.velcdn.com/images/sujipark2009/post/4832de25-ab72-4063-86ed-4ed2bd8f7273/image.png)

- 목표점 / 서브넷 마스크 / 게이트웨이 / Next Hop 인터페이스 / 메트릭

- 포워딩 테이블 및 최적 라우팅 정보를 모두 나타낸 표 테이블

메트릭 : 홉 수, 지연 시간,대역폭

- 네트워크 상태에 따라 동적으로 라우팅 테이블이 업데이트 된다.

**포워딩 테이블**

![](https://velog.velcdn.com/images/sujipark2009/post/8596b38b-5e3b-47ad-8f7a-e5aef292bbc5/image.png)

- 목표점 / 인터페이스

- 라우팅 테이블을 참조하여 만들어지는 테이블

- 입력 포트의 수신 패킷을 어느 출력 포트로 보낼 것인가를 나타낸 표 테이블

#### 라우팅 알고리즘에 대해 설명해 주세요.

---

#### 배경지식

![](https://velog.velcdn.com/images/sujipark2009/post/03ea742d-7f93-46db-bef6-e0c698f61cf0/image.png)

그래프들의 노드는 라우터, 간선은 링크이다.

링크에 있는 값은 Cost가 되며, 여기서 경로를 찾는데 COST가 가장 적은 경로를 찾아야 한다.

2가지 접근방식이 있는데,

1. **모든 라우터가 전체 네트워크 상황을 알고있는 경우**

- link state Algorithm

2. **전체 네트워크 그림이 아닌, 이웃들과의 정보만 주고받는 경우**

- distance vector Algorithm

**link state Algorithm**

![](https://velog.velcdn.com/images/sujipark2009/post/d36883dd-7db6-437b-9689-a42f4840656d/image.png)

내가 현재 노드 U인데, 전체 정보를 알기 위해서는 어떻게 해야할까?

모든 노드들이 네트워크 전체에 자신의 링크정보를 브로드캐스팅 해야한다.

각 노드들이 자신의 링크정보를 네트워크에 브로드캐스팅한다고 해서 `link state` 알고리즘이다.

이제 전체 그림을 알고있으니, 그냥 여기서 다익스트라 알고리즘을 사용하면 된다.

궁극적인 목표는, 내가 u라면 u안의 포워딩 테이블 엔트리를 다 채우는 것이다.

각 라우터들이 독립저기으로 다익스트라를 돌려서 자기자신의 라우팅 테이블을 채워나가게 되는 것이다.

근데.. 라우터가 엄청 많을건데 전체 라우터에게 다익스트라?

이건 현실적으로 말이 안된다.

현실적으로 브로드캐스팅의 범위는 어디까지일까?

서울대..고려대.. 이런 네트워크들은 다 내부적으로 라우터들로 연결되어있겠지?

그리고 그 네트워크들 사이에도 무슨 `연결` 이 있겠지?

그럼 브로드캐스팅의 범위는, `관리주체가 동일한 네트워크의 집합` 이다.

서울대 네트워크, 고려대 네트워크, SKT 네트워크,.. 이렇게 각 네트워크 안에서 브로드 캐스팅을 하게 된다.

네트워크 별로 서로 다른 라우팅 알고리즘을 사용할수도 있다.
각 네트워크 주체별로 자신의 라우팅 알고리즘을 선택하여 사용한다.
근데, 네트워크들 사이에도 라우터가 있겠지? 그리고 그것또한 라우팅일것이다.

흠.. 그럼 그 라우팅 알고리즘은 누가 결정할까? 그건 또 다른 문제이고, 뭔가 네트워크들 사이의 `합의` 가 있어야 한다.

**Distance vector**

Link State 알고리즘은, 브로드캐스팅 해서 전체 상황을 이미 알고있는 상태였다.

근데 Distance vector는, 나랑 직접적으로 연결된 라우터와 정보를 교환하면서 전체 큰 그림을 유추해가는 방식이다.

그래서 사실 직관적이지 않다.

![](https://velog.velcdn.com/images/sujipark2009/post/474fd006-5639-4a13-894d-4b120e04f95a/image.png)

이 수식만 이해하면 90%는 이해한것이다.

dx(y) : x~y까지의 최소 비용을 의미한다.

dx(y) = min{c(x,v) + dv(y)}

이것은, x에서 y를 가는데 v를 거쳐서 가는 것 중 최소를 의미한다.

![](https://velog.velcdn.com/images/sujipark2009/post/7e729f72-ab25-4808-843b-01980a2cd6c2/image.png)

예를들어, x의 이웃이 a,b,c라고 하면 y까지 가기위해서는 이 셋중 하나를 거쳐서 가게 될 것이다.

dx(a) + da(y) / dx(b) + db(y) / dx(c) + dc(y)

이 3개의 합 중에서 최소가 되는게 바로 dx(y)가 될 것이다.
c(x,v) 는 아는데, dv(y)는 알 수가 없다..

이것은 어떻게 구하냐면, 또 똑같이 재귀를 돌아서 dv(y) = min{c(v,r) + dr(y)}
이런식으로 구할 수 있다.

Distance Vector는, 자신의 distance vector들 중 하나라도 변경되는 경우 이웃에게 전달하는데,

예시를 보면

![](https://velog.velcdn.com/images/sujipark2009/post/19ff484a-2cb0-4309-9857-b5a133173ab0/image.png)

X를 기준으로

X -> X : 0 / X -> Y : 4 / X -> Z : 50

Y를 기준으로

Y -> X : 4 / Y -> Y : 0 / Y -> Z : 1

Z를 기준으로

Z -> X : 50 / Z -> Y : 1 / Z -> Z : 0

이게 각자 자신의 초기 Distance vector 상황이다.

이제 이 정보를 이웃에게 넘긴다.

![](https://velog.velcdn.com/images/sujipark2009/post/63d447ef-6e18-49ab-a929-07606bb6b880/image.png)

X는 이웃에게 distance vector를 받았으니, 다시 계산을 해봐야 한다.

dx(y) = min{c(x,v) + cv(y)} 이 공식을 적용해보자.

dx(y) = min[c(x,y) + dy(y), c(x,z) + dz(y)] 가 되고

이는 min[4+0,50+1] = 4

마찬가지로 dx(z)도 업데이트가 된다.

dx(z) = min[c(x,y) + dy(z),c(x,z) + dz(z)]

=> min[4+1,5+0] = 5

그래서 x의 레코드는 업데이트가 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/e38d1742-22da-44d2-9363-6f76cf707558/image.png)

이런식으로 레코드가 변경되어 나가는 방식이다.

X를 보면, 이전에 비해 레코드가 변했고

Y는 그대로이며

Z도 변했다.

따라서 X,Z는 이웃에게 레코드를 전파하고 Y는 보내지 않는다.

![](https://velog.velcdn.com/images/sujipark2009/post/3f94d745-8612-47fd-8467-1a045ff30fd2/image.png)

X,Y,Z 모두 이웃에게 새로운 distance vector를 받았기 때문에 다시 거리를 계산해봐야 한다.

이렇게 계산을 다 했는데 갑자기 링크의 cost가 바뀌면?

X -> Y 가 4였는데 만약 1로 바뀌면 어떻게 될까?

그럼 그 링크와 이웃한 X,Y는 다시 계산을 해봐야한다.

링크의 Cost가 4 -> 1이 되면 좋아진 것이다.(비용이 줄었으니)
이렇게 기분좋게 Cost가 바뀐경우에는 잘 전파가 되는데, 만약 4 -> 50이 되었다면 어떨까?

이때는 `Count to Infinity` 문제가 발생한다.

X -> Y가 4일때, dz(x)를 보면 5로 되어있다.

그리고 이 사실을 X와 Y에게 말하게 된다.

그럼 Y의 입장에서는, "아 Z로 가면 X를 향해서 5의 비용으로 갈 수 있구나!!" 라고 생각하게 된다.

그런데? 사실 그 길은, 자기 자신인 Y를 통해서 X로 가는 길인것이다.

이게 무슨말이냐? 다시 생각해보자

dz(x) = min[c(z,x) + dx(x), c(z,y) + dy(x)]

이게 각각 50,0 / 1,4 여서 dz(x) = 5 라는 결과가 나왔던 것이다.

근데 사실 이 경로는 Y를 거쳐서 X로 가는 경로였고.. 이 정보를 다시 Y에게 넘겨주면?

Y는 X를 향해 4의 비용으로 갈 수 있는데.. Z는 이 정보를 Y에게 전달할 필요가 없다.

오히려 이 값을 넘겨주게 되면서, X-Y의 Cost가 이상해졌을 때 `Count-to-infinity` 문제가 발생하게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/7e582b04-1c32-4ee3-b99f-2ca1a90a846d/image.png)

이게 무슨 문제냐면 여기 그림의

dy(x) = min[c(y,x) + dx(x), c(y,z)_+ dz(x)] 라는 수식에서

c(y,x)는 50이고, dx(x) : 0 , c(y,z) : 1 , dz(x) : 5 였다고 해보자.

그럼, dy(x)의 값은 6이 나올것이다.(사실 딱봐도 아니지만 진행해보자)

그럼 Y의 입장에서, distance vector가 변경되었으니 이 사실을 또 이웃인 X,Z에게 전파를 하게 된다.

그럼 Z의 입장에서 dz(x)를 계산해보면,

dz(x) = min[c(z,x) + dx(x) , c(z,y) + dy(x)]
=> [50+0,1+6] => 7이 된다.

어? 원래 dx(x)는 5였는데.. 이제는 7이 되었으니 이 정보를 또 이웃인 X,Y에게 전파를 하게 된다.

또 Y의 입장에서 dy(x)를 계산해보면,

[50 + 0 , 1 + 7] => 8로 또 변하게 되고.. 이런식으로 계속 값이 증가하게 된다.

이 과정은 50을 넘어서는 51이될때까지 계속 일어날것이다.
이런 문제를 `Count to infinity` 라고 한다.

이 문제가 발생하는 이유는 이웃에서 넘어오는 부분적인 값만 가지고 있기 때문에 한 것이다.

**그래서 Z는 X에는 넘겨주되, Y에게는 dz(x)가 무한대의 비용이라고 전달을 해야한다.**

저렇게 Y에게 Z -> X는 무한대의 비용이라고 전달을 해야, X -> Y가 4 -> 50으로 변경이 될 때, dy(x) 가 정상적인 값인 50으로 한번에 업데이트가 된다.

이렇게 무한대의 값을 줘서 이상현상을 막는 방법을 `Poisoned Reverse` 라고 한다.

...

![](https://velog.velcdn.com/images/sujipark2009/post/b46f047e-5221-4a2f-b547-11476e025168/image.png)

Link state / Distance vector 알고리즘은, Source에서 Dest까지의 최소 경로를 구하려고 사용하는 알고리즘이다.

하지만 실제 네트워크는 저렇게 끔찍하게 연결이 되어 있을 것이다.

그래서 `계층화` 를 시킨다.

서울대,고려대,연세대,.. 이렇게 각각의 네트워크로 계층화를 시킨다고 생각해보자.

각 네트워크 내부에서는 저런 알고리즘들을 돌려서 최적 경로를 찾을 수 있다.

그리고 저런 네트워크들 끼리도 또 라우터로 연결되어있고 어떤 알고리즘을 사용하게 될 것이다.

서울대 네트워크에서 구글의 서버에 접속한다고 하면, 우선 밖으로 나가는 Gateway까지는 최단경로로 이동을 하고 거기서부터 구글 서버까지 가는거는 또 다른 알고리즘을 사사용해서 이동하게 된다.

아직 네트워크들 사이의 라우팅을 어떻게 하는지는 이야기하지 않았다.

각 네트워크에서 어떤 정책을 사용할지는 그 네트워크가 결정하게 된다.
마치 우리나라 법은 우리나라가 정하는 것처럼 네트워크에도 네트워크 운영에 대한 자치권이라는 것이 있다.

이런 네트워크를 `AS(Autonomous System)` 이라고 한다.

지금까지 살펴본 알고리즘은 AS내부에서 작동하는 알고리즘이다.

이런 알고리즘을 `Intra-AS routing` 알고리즘이라고 하고,

저런 큰 네트워크들 사이의 알고리즘을 `Inter-AS routing` 알고리즘이라고 한다.

Link State 알고리즘을 실제 구현한 프로토콜을 `OSPF` 프로토콜

Distance Vector 알고리즘을 실제 구현한 알고리즘을 `RIP` 프로토콜이라고 한다.

그렇다면, `OSPF`,`RIP` 는 `Intra-AS` 알고리즘을 사용하는 프로토콜이다.

`Inter-AS` 알고리즘을 사용하는 프로토콜은 바로 `BGP`이다.

`Intra-AS` 알고리즘의 목표가 최소 비용(Cost)라고 한다면, `Inter-AS` 알고리즘의 목표는 불분명하다.

최소 경로가 목적이 아니다.

다시 살펴보면,

**AS(Autonomous System)**

하나의 라우팅 도메인에 대한 자치권을 가진 네트워크

각각의 AS는 AS number를 부여받는다.

**Relationsships Between Networks**

AS를 운영하려면, 여러 장비, 하드웨어 같은 것들이 필요하다.

결국에 이것은 "돈" 이 있어야 운영이 가능하다.

AS들은 자선단체가 아니다. 그럼 이 돈을 어디서 끌어올까?

`누군가` 가 돈을 지불하면 서비스를 제공하게 된다.

또 이 AS도 상위에 있는 ISP(SKT,KT)에게 연결되어 돈을 내야한다.

![](https://velog.velcdn.com/images/sujipark2009/post/1cdd5d3a-d7a2-4b5f-89a6-2a1b22855954/image.png)

이런 이미지가 그려지는데, Customer가 서울대라면 Provider는 SKT 이렇게 `갑을관계` 가 형성된다.

참고로 Customer - Provider는 상대적인 관계이며, SKT 또한 북미대륙을 관장하는 AT&T 에게는 또 Customer일수도 있다.

누가 갑이고 을인지는 어떻게 결정할까? => 더 필요로 하는쪽이 `을` 이 된다.

그런데 SKT와 KT사이에는 누가 갑이고 을인가? => 이런 경우에는 `Peer` 관계가 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/4a7d074f-7014-4724-bef1-43b5d807be0c/image.png)

저런 파란색의 트래픽이 생길 수 있게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/9a2ff4c0-7035-48c3-9d50-781cf75324af/image.png)

그런데 저런 검은색의 트래픽은 허용이 되지 않는다.

돈의 논리로 생각을 해보면, 트래픽이 이동할 때는 누군가가 이득을 봐야한다.

저 가운데에 있는 네트워크는 아무 돈을 받고있지 않기 때문에, 이런 트래픽은 허용되지 않는 트래픽이다.

저런 알고리즘은 Distance Vector나 Link State로는 구현이 안된다. 저런 돈의 논리가 들어간것.. 이런것을 구현한게 `BGP` 이다.

**Implementing Inter-Networko Relationships with BGP**

BGP(Border Gateway Protocol)

AS의 경계에 있는 Gateway Router사이에서 어떻게 라우팅을 할까를 결정하는 것.

**Policy Based**이다

- 최적화가 목적이 아닌, AS들 간의 정책에 따라서 좌우된다는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/a191fbc5-40f2-4ebd-a16a-71e9a2ebb093/image.png)

이런 구름으로 표현된 AS들이 있다고 해보자.

15169 번호를 가진 AS는 구글이다.

지금 이제 6341이 자신의 Prefix를 다른 AS들에게 알려주는 과정이다.

각 AS들은 네트워크 Prefix로 대표될 수 있는데, 전달하고 있는 정보(메시지)에는 Prefix와 AS Path라는 필드가 있다.

처음에 AS Path에는 자기자신의 AS Number가 들어가있다.

![](https://velog.velcdn.com/images/sujipark2009/post/cef5b383-bb9e-416b-bca0-35234eba4937/image.png)

저 정보를 받아서 다시 전달할때는, 다른건 그대로 유지하고 AS Path에 자기자신의 AS number를 추가해서 전달하게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/c4205072-25be-4616-b96f-180558579c20/image.png)

그래서 결국 AS Path에 들어가는 원소 수는 목적지까지의 홉(Hop)수를 나타내게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/46577b2d-d743-4737-8e04-4b34cf2d4d9e/image.png)

결국 삼성은 AT&T 까지 갈 수 있는 2개의 경로를 가지게 되는데 어떤걸 선택해야 할까?

두 경로 다 홉수 상으로는 동일하다.

근데 아래 경로를 보니 구글이있네?.. 거기로는 보내기싫어.. 위로 보낼래

이렇게 `정책적으로` 경로를 설정할 수 있다.

경로를 선택할 때 가장 중요한건 `돈` 이다.

![](https://velog.velcdn.com/images/sujipark2009/post/674b6a23-d34e-46ab-8c06-cd9e16e29cc1/image.png)

그림에서 Hanyang Univ. 의 입장에서 AS1이 advertise한 정보가 총 3곳에서 들어올 것이다.

딱 봤을 때, 최소 홉수를 가진 경로는 2개이지만, 한양대 입장에서는 홉수 3개를 가진 네트워크를 선택하게 된다.

왜냐하면, AS3에서 온 정보는 Hanyang Univ.의 입장에서는 `Customer` 에게서 온 정보이기 때문에 돈이 안나가기 때문이다.

**나머지는 한양대의 `갑` 에게서 왔거나 `Peer` 에게서 온 정보이기 때문에, 한양대가 `갑` 이 될 수 있는 경로를 선택하게 된다**

물론 AS내부에서는 최단경로로 빠져나가지만 AS사이에서는 나에게 가장 경제적인, 돈이 적게드는 경로를 선택하게 된다.

그래서 사실상 인터넷 상의 경로는 최단경로가 아니다.

`Inter-AS`는 최단경로 / `Inter-AS` 는 **Policy Based** 라고 기억해두자.

#### 라우팅 알고리즘에 대해 설명해주세요

---

네트워크 상의 경로를 결정하는 방법을 정의하는데 사용되는 알고리즘

**종류**

**정적 라우팅 알고리즘**

네트워크 관리자가 수동으로 라우팅 테이블을 설정하는 방법

주로 변경되지 않는 상황에서 사용하며,

- 네트워크 복잡성과 변경 사항이 적은 환경에 적합
- 라우팅 오버헤드가 없어 더 저렴한 라우터 사용 가능
- 보안성 좋음 => 관리자 권한을 가진 사람만 특정 네트워크로의 라우팅을 허용하기 때문

단점으로는,

- 대규모 네트워크에서 리소스 과다 투자ㅏ
- 관리자가 네트워크 토폴로지에 대해 잘 알아야 함

**동적 라우팅 알고리즘**

네트워크의 현재 상태를 반영하여 라우팅을 자동으로 조절하는 방법

- 네트워크 혼잡도, 링크 비용 변화, 장애 상황을 고려하여 경로를 동적으로 결정

- 구성이 쉬움
- 대상 원격 네트워크에 대한 최상 경로를 선택하고 검색하는데 더 효과적

단점으로는,

- 정적 라우팅보다 보안성이 위험
- Traffic에 따라 Cost를 책정하면 Routing loop가 생기거나 꼬이는 문제가 발생 가능
