#### 배경지식

---

링크가 유선인 상황에 대해서 이야기해보자.

우리는 패킷이 목적지까지 도달하기 위해 패킷을 쏘면 그냥 간다고 생각하고있다.

지금까지의 지식으로는, 서버까지 패킷을 보내고 싶다면 우선 패킷은 Gateway 라우터로 보내야 한다.

그래야 거기서 Forwarding을 하게되는데, 사실 Gateway 라우터로 보낸다는 것에 대해 상세히 알아볼 필요가 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/54e14653-5bbf-4c18-af21-f608e6f1690e/image.png)

원래는 패킷을 보내면 바로 일직선상으로 라우터로 가는 줄 알았지만, 실제로는 저렇게 여러 선들이 연결되어있다.

내가 패킷을 저기에 딱 올리면, 이 패킷은 사실 `Signal` 즉, 파장으로 변환이 된다.

이 `Signal` 은 갈 수 있는 모든 방향으로 퍼지게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/e8110566-4d84-4712-918b-05048af13afb/image.png)

`Broadcasting` 이 되는 매체(예를들어 공기같은..)에 패킷을 실었기 때문에 내가 Gateway 라우터에게 하려고 하는 이야기가, 저기에 연결된 모든 사람들에게 들리게된다.

이런 상황에서 만약 2명 이상이 동시에 무언가를 말한다면? 파장이 섞이게 된다.

이것을 `Collision` 이라고 한다.

충돌이 발생하면 신호가 섞이게 되고 Gateway 라우터 입장에서는 이해할 수 없는 정보가 들어오게 된다.

핵심은, 많은 사람들이 공유하고 있는 매체를 통해서 메세지를 전달하기 때문에 충돌이 발생하지 않아야지만 제대로 메세지가 전달된다는 것이다.

그래서 Link Layer에서 하는 가장 중요한 일은, **충돌이 발생하지 않게, 혹은 충돌이 발생했을 때 그것을 해결하는 것** 이다.

이 계층에서 할 이야기는, 한 Hop을 어떻게 갈 것인가 이다.

다음 홉 까지 충돌이 나지않게 어떻게 잘 보낼 수 있을까.. 이것을 알아보자.

우선, **유선** 인 상황에서 알아보자.

#### Link Layer는 어디에 구현되어있는가?

---

Transport,Network 는 OS안에 코드로 구현되어있다.

하지만 Link Layer는 NIC(Network Interface Card)안에 구워져있다.

Network에서 내려온 패킷이, NIC에서 외부로 나갈 때 Link layer의 전송단위인 `Frame` 의 Data 부분으로 들어가서 전송이 된다.

#### Multiple Access Links, Protocols

---

만약, 호스트와 호스트 사이에 전용선이 있다면 그 선에 데이터를 올리면 바로 전달이 될 거니까 우리가 신경이 쓸 필요가 없을것이다.

근데 그런일은 잘 없고.. 많은 사람들이 공유하는 채널을 가진 링크를 사용하게 된다.

그래서 어느 한 곳에서 Signal을 보내면 그것이 다 퍼지게 된다. 그래서 문제가 발생하는 것이다.

이런 매체를 `Broadcast Medium` 이라고 한다.

우리가 말을할때 사용하는 매체는 `공기` 이다.
그래서 한명이 이야기하면 괜찮은데, 여러명이 이야기하면 섞여서 문제가 생긴다.

매체에 무언가 Signal을 실을 때 / 매체에 접근을 할 때, 이런 접근을 좀 조절해서 충돌을 조정하려고 하는걸 `Medium Access Control` 이라고 부른다.

줄여서 `MAC`. `MAC`라고 하면 뭔가 **충돌을 해결하려는 것에 관한 것**이라고 생각하면 된다.

카페에서 노트북을 킨 사람들은 다 같은 네트워크를 사용하고 있고, 같은 매체를 공유하고 있는 상황이다. 그래서 여러명이 동시에 말하면 충돌이 발생하는데, Wi-fi라는 프로토콜이 이것을 잘 Control해서 충돌이 안나게 해준다.

MAC 프로토콜에 대해서 이야기해보자.

이상적인 프로토콜은 다음 4가지를 가지고 있어야 하는데, 링크의 채널 Bandwidth를 R bps라고 했을 때

1. 한 노드가 데이터를 전송하고 싶을 때 온전히 R만큼 보내고 싶다.
2. M개의 노드가 동시에 보내고싶은경우, R/M 씩 Bandwidth를 사용할 수 있어야한다.
3. 중앙 서버가 아닌, 분산서버면 좋겠다.
4. 단순했으면 좋겠다.

이런 4가지를 가지고 있으면 좋겠다는게 이상적인 MAC 프로토콜이고
이런것들을 조금이라도 만족시키기 위해 몇백개의 프로토콜이 제안되었는데, 그것들을 크게 3가지 카테고리로 나눌 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/ec2f2d34-9336-4830-94be-7695854c3d5a/image.png)

1. **Channel Partitioning**

![](https://velog.velcdn.com/images/sujipark2009/post/ef18ff7a-4b10-43ea-9066-e4b9c1e2e68d/image.png)

대표적인 프로토콜은 `TDMA(Time Division Multiple Access)` 가 있다.

- 말 그대로 시간을 쪼개서 여러사람들이 Access 할 수 있게 만든다.
- 각 사람별로 전송할 수 있는 Time slot을 할당해서 자기 차례가 왔을때만 전송할 수 있도록 하자.

문제점은, 그림에서도 볼 수 있듯이 촘촘하지가 않다는 것이다.

만약 유저가 1명만 있으면 나머지는 낭비가 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/44a2fb51-65e7-4f20-b2eb-400c39044523/image.png)

`FDMA(Frequency Division Multiple Access)`

TDMA와 똑같다. 각자 자기자신의 데이터를 보낼 수 있는 주파수가 배정되어 있다는 것이다.

TDMA와 동일한 단점이 존재한다.

2. **Random Access**

그냥 내가 보내고싶을때 보내면 안될까? 근데 그러면 당연히 충돌이 일어날 수 있겠지?

여기서는 충돌을 어떻게 탐지할 것이며, 충돌이 났을 때 어떻게 해결할것이냐가 중요하다.

`CSMA(Carrier Sense Multiple Access)` 방식이 있는데,

캐리어를 센싱한다는게 무엇일까?

캐리어는, 짐을 싣고가는 매체를 말한다.
여기서의 핵심은 `Listent Befroe Transmit` 인데, 말 그대로 말하기 전에 듣는다는 것이다.

이건 Broadcast Medium이면 어디든지 적용할 수 있는데, 예를보면

5명이 이야기하는데, 공기라는 Medium을 이용해서 대화를 할 것이다.
근데 말이 겹치면 이해를 잘 못하니까 한명씩 이야기를 하게 될 것이다.

내가 하고싶은 이야기가 있어도, 바로 이야기 하지 말고 누군가가 이야기를 하고 있으면 끝날때까지 기다려야 한다.

이렇게 하면 충돌이 안나겠지? 라고 생각하지만, 일상생활을 해보면 충돌이 난다.
조용해졌을 때 서로 각보다가 동시에 그...그... 이런식으로 서로가 동시에 말한다면?
이 경우가 바로 CSMA를 사용했을 때 충돌이 나는 경우이다.

![](https://velog.velcdn.com/images/sujipark2009/post/c1f99d9f-638e-4005-9e92-dbec6ea6c0a4/image.png)

T0 시간에 링크를 들어보니 조용하길래 Signal을 보냈는데, 그 신호가 가장 멀리있는 노드에 아직 도착을 안해서 누군가가 또 T1시간에 프레임을 전송한다고 해보자.

![](https://velog.velcdn.com/images/sujipark2009/post/207aa6ad-aede-406e-b971-b3f94d44c8d4/image.png)

그럼 저렇게 겹치게 되는 `충돌` 이 발생한다.

여기서 핵심은, 충돌이 발생한 이유는 바로 `Propagation Delay` 때문이라는 것인데

만약 신호를 쏘자마자 바로 도달했었으면, `Carrier Sense`를 했을 때 인지를 했을 것이다.

그럼 Propagation Delay를 0으로 만들면 되는거 아닌가?

전파속도는 빛의 속도이기때문에, 이것보다 빠르게하는건 불가능하다.

여기서의 결론은, **충돌은 나기 마련이다** 라는 것.

그럼 이제, 충돌을 피할 수 없다는걸 알았다.

그럼 서로 충돌이 났음에도 불구하고 서로가 자기자신의 이야기를 계속 하게 되는가?

그건 아니다.

현실에서는 충돌이 나면 바로 서로의 말을 종료하게 되는 것처럼, 어차피 충돌이 나서 다 `Noise` 가 되는데.. 동시에 멈추는게 낫다.

그게 바로 `CSMA/CD` 이다.

`CSMA`랑 똑같은데, 충돌을 감지하고 바로 전송을 멈추는 것이다.

전송을 하고있는데 다른 사람이 또 이야기를 시작했어.
그래서 내 Signal과 합쳐져서 충돌을 감지하게 된다면, 바로 중단한다는 것이다.

그럼 그 다음은 어떻게 할 것인가? 에 대한 문제가 생기는데.
이것에는 규칙이 없다. 둘 중 하나는 이야기를 빨리 시작해야한다.

근데 **누가 먼저 할 것인가?**

어떤 중재자가 있어서, A먼저 말하세요~ B먼저 말하세요 하면 좋은데 그런게 없으니 애매하다.

그래서 이런 상황을 `CSMA/CD` 에서는 이렇게 명시를 해놓았다.

**`Binary Backoff`**

{0,1,2,...,2^n-1} 이런 시간단위가 있다고 해보자.

예를들어, 1ms,2ms,...,..n번의 충돌이 있었다면 여기서 랜덤하게 한 숫자를 선택해서 기다리는 것을 의미한다.

A가 프레임을 전송하고 충돌을 탐지했다고 해보자.
그럼 충돌이 1번난거니까, {0,1} 중 하나를 골라서 그만큼 기다렸다가 다시 전송하게 된다.

그래서 충돌이 적게나면 기다리는 시간이 적지만, 충돌이 많이날수록 기다리는 시간의 범위가 늘어날 수 있다.

결국, 충돌이 계속 나게됨에따라 오래기다릴 확률이 높아진다.

근데 왜 이런식으로 해놨을까?

내가 프레임을 보냈는데 충돌이 났다면, 내가 알 수 있는건 **몇명인지는 모르지만, 나말고 누군가가 프레임을 보내고있다**는 것이다.

만약 사람의 수가 적다면 오래기다릴 필요가 없다.
근데, 10명이 이야기하는데 숫자4개중에 하나 골라서 기다리라고하면?.. 막 충돌이 날 것이다.

그래서 처음에는 낙관적으로 적은 숫자를 고르게하고 충돌이 날수록 더 넓혀나가는 것이다.

이 Backoff는 결국 `delay` 인데,

이 시간이 길면 길수록 오래 기다린다는 것이다.
이 Backoff 시간은 충돌이 많이 날 때, 즉, 사람이 많을 때 느려지게 된다.

사람들이 많이 몰렸을 때 느려진다고 느끼는 이유는 실제 이런이유 때문이다.

이게 `Random Access` 의 장점이자 단점이다.

3. **Taking Turns**

`Channel Partitioning` 은 사람이 많으면 유리하고, `Random Access`는 사람이 많으면 불리하다.

이 두가지를 복합적으로 해볼수는 없을까?~ 해서 나온 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/1ed10a10-bd59-42d4-8c00-675447756059/image.png)

어떤 Master Controller가 있어서, "지금 뭐 있냐?" 물어보면 알려주는 것이다.

근데 여기는 **SPOF(Single Point of Failure)** 문제가 존재한다.

![](https://velog.velcdn.com/images/sujipark2009/post/bcc75013-748a-4e02-abe4-68a4c36da999/image.png)

또한, Token을 가지고 있는 호스트만이 데이터를 전송할 수 있게 되는데
여기서 문제점은, 누군가가 토큰을 잃어버리면? 망하게된다.

이렇게 하나에 의존하여 Sync를 맞추는것은 `SPOF` 위험이 존재한다.
그래서 일반적으로 Random Access 방식 중 `CSMA/CD` 를 사용한다.

실제 `Wi-fi`에서는, 비슷하지만 무선이기에 조금은 다른 `CSMA/CA` 를 사용한다.

**LAN(Local Area Network)**

서브넷 이라는것에 대해 이야기했었는데, **같은 Prefix를 가지며 라우터를 거치지 않아도 접근가능한 호스트들의 집합** 이라고 했었다.

결국 서브넷이라는건 LAN으로 구성된 것이다.
그런 호스트들이 서로 LAN으로 연결되어있다.

LAN을 링크로 사용하는 `Ethernet` 에 대해 알아보자.

#### Ethernet

---

Link Layer에서 말하는 것은 모두 `MAC` 프로토콜로, 충돌을 해결하기위한 프로토콜이다.

LAN에서 적용되는 MAC 프로토콜이 바로 `Ethernet` 이다.

![](https://velog.velcdn.com/images/sujipark2009/post/e8e43217-2aa8-44bc-9261-5df815e16da4/image.png)

저렇게 가운데 스위치를 두고 연결되어있다.

#### Ethernet Frame Structure

---

Link Layer의 전송단위는 `Frame` 이다.

이 Frame도 당연히 헤더가 존재하는데,,

![](https://velog.velcdn.com/images/sujipark2009/post/c8f80005-79a6-4240-82ea-8619c9cfde6a/image.png)

- CRC는 에러체킹에 사용하는 부가적인 정보
- Type은 이 안에 들어가는 데이터가 어떤 상위레이어의 프로토콜인지를 의미

상대방이 프레임을 받게되면, 그것을 상위 레이어로 올리게되는데 그때 Type을 보고 올린다. 대부분이 IP Protocol

중요한것은, Link Layer에서 어떻게 충돌을 해결할것인가 라고 했었다.

Ethernet에서 사용하는 MAC Protocol은 `CSMA/CD` 인데

Carrier Sense Multiple Access / Collision Detection 이라는 의미이다.

말하기전에 듣고, 아무도 말하지 않으면 말을 시작할 수 있는데 충돌이 나면 즉시 멈추고 기다린다는 의미이다.

그리고 충돌시에는 `Binary Backoff` 만큼 기다린다.

Collision을 Detect하면 프레임이 멀리 못갔다는 거니까.. 재전송을 한다.

근데 생각해보면, `TCP` 에서도 재전송을 했었다.

TCP 재전송의 근거는, 내가 Segment를 보냈는데 ACK가 오지않고 타이머가 터졌을 때였다.

지금은, Link layer에서 내가 프레임을 보냈는데 그게 Collision이라고 판단되면 재전송을 하게 된다.

기왕이면 Link layer에서 재전송을 하는게 더 낫다. 왜냐하면 더 Cost가 낮기 때문이다.

Collision Detection이 안났다? => 난 99.9% 나의 프레임이 도착했다고 확신하는 것이다.

혹시라도 Collision이 발생했는데 그걸 Detect하지 못하는 경우가있다면?
그건 아주 큰 문제일것이다..

다시보면,

유선 Ethernet의 상황에서 Collision이 발생하면 데이터가 제대로 도착하지 못한다고 했다.

근데, 유선의 상황은 외부로부터 보호받는 상황이기 때문에 대부분은 전달이 된다.
케이블 덕분에 Collision만 없다면 거의 100% 도달하게 된다.

그래서 Ethernet에서는 굳이 피드백을 주지 않아도 되는 것이다.

그럼 반대로 말하면?

만약에 Collision이 발생했는데 그 충돌을 감지하지 못한다면 그건 큰 문제가 된다는 것이다.

근데.. 그런 경우가 있을까?

A --------B--------C-----------D-------------E

이렇게 케이블이 있다고 해보자.

A가 D에게 데이터를 보내려고 하는 상황이다.

A가 Carrier Sense를 했는데 아무것도 안들려서 전송을 시도한다.

그때 E가 B에게 보내려고 시도한다면?

E가 Carrier Sense를 하면 아무것도 안들릴것이다.

가장 최악의 상황은 A의 신호가 E에 도달하기 직전에 E가 Carrier Sense를 하는 것이다.

그럼 E는 자신의 프레임을 보내려고 할 것이고 보내자마자 Collision Detect를 할 것이다.

근데, 그 찰나의 순간에 보낸 데이터는 A를 향해 날아가게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/234f3117-f17b-424d-85d0-14a601b3896c/image.png)

저기서 E는 CD를 해서 재전송 할 프레임이 존재하는데, 그럼 A는 어떻게 해야할까?

A가 CD를 하려면 방금 그 찰나의 순간에 E가보낸 프레임을 만나야 한다.

근데 그 프레임이 A에게 도달하기 직전에 A가 모든 프레임을 다 보냈다면?

A는 실제로 Collision이 일어났지만, 이 충돌을 인지하지 못하게 된다.

A가 조금만 더 말을 길게 했으면.. CD를 할 수 있었을텐데.. 라는 생각이 든다.

결국이것도 `Propagation Delay` 때문에 생긴 문제이지만 빛의 속도이기에 고칠수는 없다고 했다.

그래서 A는 할말이 많이 없어도 어느정도는 이야기를 해야한다!! 라고 명시해 둔게 ㅎ있는게 그게 `Minimum Frame Size` 이다.

A가 A~E 길이 대비 어느정도는 말을 해줘야 한다는 것이다.

저 Size는 64B인데, A가 실제 1B를 보내려고 했다면 의미없는 Padding을 넣어서 64B를 보내야한다는 것이다.

이제 Ethernet 헤더에 들어있는 `MAC Address`에 대해 이야기해보자.

#### MAC Address

---

![](https://velog.velcdn.com/images/sujipark2009/post/55bd7baf-ea7e-4689-a5c3-3af5f7dc87d0/image.png)

Link layer에서만 사용하는 주소체계가 `MAC Address` 이다.

48bit의 주소인데, 이걸 24bit씩 끊어서 사용한다.

앞은 제조회사를 나타내고 뒤는 고유 Number를 나타낸다.

MAC Address는 바꿀 수 없는 주소이다.

이런 MAC 주소가 Frame의 헤더에 들어가게 된다.

컴퓨터에서 가장 처음으로 보내는 개체가 바로 Gateway Router인데,

이때 실제 보내지는 건, IP Address를 감싼 프레임이 전송이 된다.
그럼 실제 Destination Address는 뭐가 되야할까?

![](https://velog.velcdn.com/images/sujipark2009/post/e4dd5c39-6425-4e02-b250-724a21c16224/image.png)

A가 GWR(Gateway Router)에게 프레임을 보낼건데, 어디로 보내야할까?

GWR의 IP주소를 우리가 안다고 해보자.
만약 알고있다면, 그건 `DHCP` 를 통해서 알아온 IP일 것이다.

그래서, "아~ 이제 필요한게 있으면 저기로 보내면 되겠다!" 하고 인지하고 있는 상황이다.

이제 구글로 향하는 IP Packet을 만들었는데, 여기서 Source IP는 나의 IP이다.

목적지 IP는 구글의 IP가 들어가야한다.(그리고 이건 DNS에서 알아왔을 것이다)

이런 IP 패킷이 실제는 MAC Frame의 DATA부분으로 들어오게 된다.

그럼 결국 A에서 GWR로 가기 위해서는 Source는 A의 MAC Address(이건 `나`니까 이미 알고있는 것), Destination은 GWR의 MAC Address여야되겠지?

근데 우리는 GWR의 MAC Address는 모른다. 왜냐하면 DHCP는 GWR의 IP 주소만 알려줬기 때문이다..

그래서 IP 주소를 가지고 MAC address를 찾는 과정이 필요한데, 이건 `ARP` 프로톸을 사용한다고 했었다.

각 호스트 내부에 `ARP Table` 이라는 테이블이 존재하고, 그 테이블에는 IP주소와 Mac address의 매핑을 적어놓은 정보가 들어있다.

근데, 저런 Entry는 처음에는 테이블에 없었겠지?

어떻게든 채워야하는데, 그걸 처음에 채우는 프로토콜이 ARP이다.

`ARP Request` 라는 Frame을 LAN 전체에 Broadcasting한다.

![](https://velog.velcdn.com/images/sujipark2009/post/8205dfde-1477-4be0-8eda-c275c750dccf/image.png)

이때, Source를 `나` 로 설정하고 Destination은 GWR이 될 것이다.

GWR은 해당 프레임을 받아서 IP를 까보고 "어 나한테 보낸거네?" 를 인식한다음 MAC Address를 나에게 전송하게 된다.

참고로 ARP Table에는 또다른 필드가 있는데 `TTL`이 있어서, 몇 시간동안만 유효한 Entry가 된다.

ARP Table은 사실 일종의 Cache Table이여서 시간이 지나면 다시 ARP Request를 해야한다.

![](https://velog.velcdn.com/images/sujipark2009/post/0e3d7c98-eadc-47b9-880b-cd5cacd06eb4/image.png)

자.. 그러면, CSMA/CD를 시도해서 프레임을 보내겠지? 그래서 GWR이 받았어

그럼 GWR은 3계층까지 까보고, Source IP : A, Destination : Goole IP인 패킷을 확인하게 된다.

그러면 GWR이 이걸 받고 하는일은, Forwarding을 해야하니까 어디로 Forwarding할지를 선택해야한다.

Forwarding 테이블을 참조해서 목적지에 해당하는 곳으로 보내야한다.

그래서 보내기위해 다시 이 패킷을 Frame으로 감싸서
Source : GWR의 MAC주소가 들어가게 되는데, 이때 Source의 MAC주소는 이전의 MAC주소와는 다른 주소가 된다.(NIC가 다르기 때문에)

![](https://velog.velcdn.com/images/sujipark2009/post/8ac40db3-6521-44e8-88e1-a02f997f77fe/image.png)

그림의 왼쪽 빨간점과 오른쪽 빨간점의 MAC주소가 다르다는 것이다.(라우터는 여러개의 NIC를 가질 수 있었다)

Destination은 R1의 MAC Address가 되어야하는데, 이것도 ARP Table을 확인하면 알 수 있다.

이렇게 계속 같은 방식을 사용해서 최종목적지까지 전송이 된다.

결국, 처음 출발점인 A부터 시작해서 Source IP는 변하지 않고 매번 홉을 거칠때마다 Frame의 MAC Source,Dest만 변하면서 이동하게 되는 것이다.

이 과정에서 Forwarding Table + ARP Table을 참조하면서 전달하게 된다.

...

![](https://velog.velcdn.com/images/sujipark2009/post/030a4a10-8856-4f55-9e09-8783169c34c7/image.png)

다시 정리하면, A에서 다른 네트워크에 존재하는 B에게 데이터를 보내려고 한다.

라우터는 지금 NIC가 2개있는데 각각 MAC주소와 IP주소가 다르다.

A의 내부에 있는 Forwarding Table에는 아마, 외부로 나가는 데이터는 111.111.111.110(R)로 가라고 되어있을 것이다.

이제 프레임에는 MAC주소도 같이 담아야하니까, A는 ARP Table을 찾아보고 111.111.111.110에 대한 MAC주소를 찾는다.

테이블에 없는경우 Broadcast를 통해 알아낸다고 했다.

마찬가지로 R에서도 Forwarding Table + ARP Table을 찾아보고 패킷을 생성한다.

IP주소는 처음 그대로이고 MAC주소를 다시 쓰면서 생성한다.

Q. **Forwarding 테이블은 라우팅 알고리즘으로 생성하게 되고, 근데 그걸 하게되면 ARP Table도 알게되지 않나?**

맞다.

근데 굳이 여기서 이야기하는 이유는 ARP 테이블에 있는건 무한정 기록되어있는게 아니라 TTL이 존재해서 사라지게 되므로, 그런경우 `ARP Request`가 필요하기 때문이다.

#### Switch

---

Link Layer를 이야기하면서,

![](https://velog.velcdn.com/images/sujipark2009/post/27283ddb-5f2f-4b2f-865f-ac6d7785b3c0/image.png)

이런 그림을 이야기했었는데.. 그럼 새로운 호스트가 추가될때마다 저기에 힘들게 연결해야할까?

아니다. 스위치라는게 존재해서 그 포트에 케이블을 꼽기만 하면 된다.

스위치의 장점은, 바로 **Collision Domain을 분리** 시켜준다는 것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/8942b19e-fe49-49eb-8cdf-bee731f352d6/image.png)

왼쪽에서는 매체에 시그널을 보낸다면 전체로 퍼지게되는데, 오른쪽에서는 스위치를 기준으로 상하좌우 4개로 Domain이 분리가 된다.

또한, 스위치는 **호스트들의 눈에는 보이지 않는다**

호스트의 입장에서는, **스위치의 존재조차 모른다**
그래서 그냥 원래 하던대로 CSMA/CD를 하면 된다.

스위치는 단순히 연결만 시켜주는 것이라 MAC주소도 없다..

![](https://velog.velcdn.com/images/sujipark2009/post/39488640-dc93-4666-9ef1-4452ee939405/image.png)

도메인이 분리되어있기에, A -> A´, B - > B´으로 동시에 데이터를 보낼 수 있게된다.

근데 만약 A,B가 동시에 A´으로 보낸다면? => 스위치가 알아서 정리를 해준다.

근데, 스위치의 입장에서 Source : A, Dest : B가 왔을 때, 어디로가야 B인지는 알 수 있어야 한다.

스위치안에도 `Switch Table` 이라는게 있어서, Source | Dest | TTL 의 정보가 존재한다.

약간 라우터와 비슷한데, 라우터는 라우팅 알고리즘을 통해 Forwarding Table을 채웠었다.

그럼 Switch Table도 누가 만들어줘야하는데, 이건 `Self learning` 이라는 기법으로 채우게된다.

A -> A´으로 가는 데이터가 왔다면, **스위치는 최소한 A의 포트는 알게되는 것이다**

A의 입장에서 A는 저 프레임을 만들어서 A´으로 보내려고 하는거지, 스위치로 보낸다는건 모른다.

이제 저 프레임을 스위치가 받아서 `Self-learning`을 해서 "아 A는 1번포트구나~ 근데 A´에게 보내야하는데.. 내 테이블을 보니까 없네?.."

방금 들어온 1번포트를 제외한 나머지 포트들에게 다 보내보는 수밖에 없다(Flooding)

이제 A´이 A에게 보내려고 할 때, "아 A´은 4번포트네~" 이걸 기록하고 아까 1번포트에 있던 A에게 보낼 수 있게 된다.

`플러딩(Flooding)`은 거의 처음에만 나타나는 개념이다.

근데.. 이제 사람이 많아져서 8개포트짜리 스위치를 샀는데 사람이 20명이라고 해보자.

![](https://velog.velcdn.com/images/sujipark2009/post/81413939-d078-4984-b16c-ac2cfb5582a0/image.png)

그럼 스위치를 더 사서 연결시키고 계층화를 시키면 된다.
스위치가 등장해서 뭔가 더 특별하다고 생각하면 안되고,, 네트워크 레이어 관점에서는 스위치는 없고 그냥 라우터에 연결된 호스트들로 보인다.

근데 다 연결하기 어려우니까 스위치를 사용해서 연결하게 되는것이다.

![](https://velog.velcdn.com/images/sujipark2009/post/cdfe820f-6649-41bb-b7b5-3938b05a22a5/image.png)

여기서 문제. A에서 I로 보내려고 할 때 어떻게 포워딩을 해야할까?

`Self learning`을 활용해야한다.

처음에 C가 I에게 프레임을 보내려고한다고 해보자.

![](https://velog.velcdn.com/images/sujipark2009/post/6bb487a4-7bf5-4825-89c5-7c1f1f6479a9/image.png)

C가 CSMA/CD를 사용해서 조용할 때 보내면, S1이 받아서 Self learning을 통해 C가 3번포트에 있다는걸 알게된다.

I의 포트를 모르니까.. 플러딩을 통해 S4에 도착하게 된다.

S4는 또 Self-learning을 하게된다.
S4는 I를 찾으려는데, 또 없으니까 방금 들어온 S1포트를 제외한 나머지 포트로 플러딩을 하게된다.

S2도 Self-learning을 하고 I가 없으니 또 플러딩.

S3도 I를 모르니까 플러딩을 하고, 이제 I를 알게된다.

이제 I가 C에게 응답하는 프레임을 만들었다고 해보자.

I가 CSMA/CD를 통해 전송 => S3가 받아서 Self-learning을 하고 C에대한 정보가 있으니 S4로 전송

S4는 또 Self-learning을 하고 S1으로 전송 => S1은 또 Self-learning을 하고 C로 전송..

이렇게 처음 갈 때는 복잡하게 퍼지면서 갔지만, 올때는 바로 오게 된다.

Q. 공유기와 스위치의 차이는 뭘까?

회사에서 사용하는 케이블을 통해 모뎀을 통해서 공유기로 들어가게 되는건데
원래는 컴퓨터 1대에만 연결되야 하는걸 **공유기 컴퓨터**에 연결해서 여러명이 함께 사용할 수 있도록 하는 것이다.

참고로

![](https://velog.velcdn.com/images/sujipark2009/post/6f37e7e6-2bed-4722-bc15-391e55e74bf3/image.png)

...

왜 **컴퓨터**냐면, 공유기안에 Application layer 계층까지 구현되어있기 때문이다.

Application layer의 NAT가 동작해서 ISP로부터 받은 IP를 사설 IP로 변환하여 배정해준다.

그 공유기에 `DHCP`도 동작하고, `Local DNS`도 동작하고있다.

한마디로, 여러 호스트들이 게이트웨이 라우터에 연결되어있다고 보면된다.

뭔가 공유기가 스위치처럼 느껴지지만 저건 `라우터` 다.
그냥 라우터라 하기는 뭐하고.. DHCP,DNS,NAT 다 동작하니 작은 컴퓨터라고 할 수 있다.

근데 스위치는 저런 기능 없이 그냥 엮어만 준다.
만약 집에 사람이 더 많아지면 저런 공유기의 포트수도 부족하게 되는데, 거기에 또 스위치를 연결하거나 공유기를 꽂아도 된다.

공유기에 공유기를 꽂으면? 라우터 - 라우터를 연결한다고 보면된다.

![](https://velog.velcdn.com/images/sujipark2009/post/c3516da9-cf50-4a3f-86f4-af682307ed60/image.png)

이렇게 연결된 개념으로 보면된다.

일종의 다른 네트워크 Prefix로 연결된다고 보면 되고.. 그래서 사람이 늘어날 때 확장하는 방법이 스위치,라우터 붙이기가 있다.

라우터를 붙이면 라우팅이 일어나는 것(서브넷이 생기기 때문)이라, 스위치를 붙이는게 더 간단하다.

...

우리는 Link Layer에서, 첫 Next Hop인 Gateway Router까지 어떻게 갈 것인가에 대해 이야기를 했다.

그리고 저 Link는 여러 호스트와 공유하는 `Broadcast Medium` 이었다.

그래서 충돌이 날 수 있고 그걸 피하는 프로토콜이 `MAC Protocol`이라고 했다.

유선에서의 MAC Protocl은 `CSMA/CD`였는데, 그럼 무선링크인 상황에서는?

개념적으로는 거의 동일하다.

무선링크의 경우, 공기라는 하나의 Medium을 통해 전달하기 때문에 충돌이 발생하기 마련이다.

#### Wireless

---

무선 인터넷이라는것은, 사실 첫 홉만 무선이라는 것이다.

결국, **첫 홉을 무선으로 어떻게 갈 것인가** 에 대해 이야기 할 것이다.

#### 무선링크의 특성

---

유선 이더넷에서는 Signal이 케이블을 통해 전달이 된다.
케이블은 외부의 Noise에서 차단되어 안정적으로 Signal이 전달이 된다.

유선은 전송속도와 거리가 늘어남에따라 거의 일정하다.

무선은 점점 떨어진다.. 약간 호수에 돌을 던지고 파형이 퍼지는것 처럼..

외부에서 간섭이 심하기 때문이다.

Wi-Fi가 사용하는 2.4Ghz는 Open되어있는 주파수라서 난잡하다.

무선 호스트 A,B,C가 있다고 해보자.

만약 유선으로 연결이 되어있다면, A가 하는말이 B,C에게 전달이 될 것이다.

근데 무선이라면,

각 거리가 80m이고 전송반경은 100m라고 해보자.

A -> B, C -> B는 B가 들을 수 있다.
하지만 A -> C, C -> A는 들을 수 없다.

그러면, `CSMA/CD` 가 동작할 수 있나?

A는 C가 말하는걸 들을 수 있어야 하는데 애초에 닿지를 않으니.. C가 전송하고 있는지 알 수 없어서 A의 데이터가 방해받을 수 있다.

또 무선 네트워크의 가장 큰 특징이자 문제점은 `Collision Detection`이 불가능하다는 것이다.

**내가 무언가를 전송하고 있으면 Noise가 너무 커서 다른것들이 잘 안들린다는 문제가 있다.**

마치 내가 말하고있으면 상대방의 소리가 잘 안들리는 것처럼 / 내가 이어폰을 꼽고있으면 잘 안들리는 것처럼..

Wi-Fi의 MAC 프로토콜을 알아보자.

![](https://velog.velcdn.com/images/sujipark2009/post/3d2bc50d-a528-4206-993f-90129b9bca33/image.png)

Wi-Fi하면 저런 그림을 연상해야한다..

가운데 AP가 있고, AP와 통신을 하는 것.

`AP`는 유선으로 네트워크에 연결된 무언가이다.

위의 그림에서 A가 말을 하더라도 C는 들을 수 없다. C가 Carrier Sense를 하면 조용하다..

근데 심지어 C는 충돌감지도 할 수 없다.(아까 뭔가를 보내고 있을때는 Noise가 커서 다른 것들을 들을 수 없다고 했으므로)

충돌이 나는데 충돌 감지가 안된다? 어떻게 해야할까.

유선에서는 충돌이 나면, 데이터가 안갔으니 재전송한다의 흐름이었다.

유선에서는 충돌감지를 할 수 있기에 ACK가 필요없었다.

근데 Wi-Fi에서는 충돌이 일어날 수 있는 환경이지만, 내가 그걸 감지할 수 없는 상황이다.

그래서 **상대방이 나에게 알려줘야 한다**. 이 말은 무선에서는 ACK가 필요하다는 말이다.

근데 TCP의 ACK와는 완전히 다른 개념이다.

TCP의 ACK는 End-To-End Feedback이었다면, 여기는 Link Layer의 ACK이다.

한 홉을 잘 갔는지를 알려주는 ACK인 것이다.

동작을 살펴보면,

Wi-FI에서 사용하는 MAC는 `CSMA/CA`로, A는 Avoidance를 의미한다.

우선 처음에 Sender가 보낼 데이터가 있으면 Sensing을 해보고, 있으면 Random backoff를 사용해서 Random시간만큼 기다리고 보낸다(여러 사람이 있을 수 있기에)

CS(Carrier Sense)했는데 조용했다? => `DIFS` 라는 정해진 시간동안 채널이 조용하면 보낸다.

Receiver는 받았으면 정해진 시간(`SIFS`) 만큼 기다렸다가 ACK를 보낸다.

Sender가 데이터를 보냈는데 ACK가 안왔다? => 충돌이 발생했구나!! 하고 재전송하게 된다.

기본적으로는 데이터를 보내면 ACK가 오는 구조이다.

CSMA/CD와 동작차이를 비교해보면, CSMA/CD에서는 데이터를 보냈는데 충돌을 감지했다면 바로 멈춘다.

CSMA/CA에서는, 내가 이야기를 시작하면 무조건 다 이야기를 해야한다. 왜냐하면 충돌이 난지를 모르기 때문이다.

무선은 충돌이 발생하면 다 날아가버리니까 피해가 크다.. 그래서 더 조심해야한다.

그런데, 이 CSMA/CA만 봤을때는 충돌을 피하려고 하는 노력은 보이지 않는다.

ACK를 받을때까지 충돌~충돌 충돌~ .. 어 받았네!! 라고 하는 것.

충돌의 피해가 상당히 크다.

그래서 이걸 더 줄여보자는 의미로 CSMA/CA에다가 `RTS-CTS` 라는 Control Frame을 추가시켜서 Collision을 줄인다.

`RTS(Ready to Send)` , 내가 보내기 전에 주변에게 알려주는 것.

`CTS(Clear to Send)` , OK 보내라는 것.

문제는 CSMA/CA에서 데이터를 바로 전송하는데 **충돌이 나면 다 날아간다는 것이었다. 충돌에 대한 위험성이 있음에도 다 보내는게 문제인 것이다**

그래서 다 보내는게 아니라, 작은걸 먼저 보내고 충돌이 났는지 안났는지 먼저 확인해보자는 아이디어이다.

B가 AP에게 전송하려는 데이터가 있다고 해보자.

우선 CS를 해보고 괜찮으면 바로 데이터를 보내는 것이 아니라 내가 보낼 데이터가 있다는 RTS를 AP에게 우선 전송한다.

그런데 마침 어딘가 있던 A도 보낼 데이터가 있어서 RTS를 AP에게 전송한다.

그럼 동시에 도착하면 충돌나겠지? AP는 저걸 해독할 수가 없다.(충돌이 나는경우 Noise가 발생하기 때문)

그래서 원래는 CTS를 보내줘야하는데, 가만히 있게 된다.

RTS 충돌은 작은 사이즈라 타격이 크지않다. A,B둘 다 CTS를 못받았으니 Random Backoff를 한다.

A가 다시 먼저 보낸다고 해보자. 그럼 AP는 그걸 받고 CTS를 양쪽으로 보낸다.

저건 퍼져나가는 정보이니까, AP를 포함해서 A주변의 애들이 다 A의 RTS를 받는다.

그래서 A의 주변은, "아~ A까 얼마나 채널을 사용하려고 하는구나~" 를 알게된다.

그걸 받은 AP는 통신반경에 CTS를 보내게 되는데, B에게도 이게 퍼져나가게 된다.

CTS를 받은 A는 안전하게 데이터를 전송하고 AP는 ACK 메세지를 보내게 된다.

A가 데이터를 전송하는 동안, B가 CS를 하면 조용할것이다. 근데 B는 CTS를 받았으니 "아~ 내가 지금 보내면 안되겠구나~" 라고 생각하게 된다.

그러다가 ACK를 받으면 또 보내려고 시도할것이다.

Q. A와 B가 간발의 차이로 AP에게 보낸다면?

A의 RTS에 대한 CTS를 AP가 B에게 보낼 때, B가 동시에 RTS를 보낸다면?

그럼 섞여서 Noise가 된다.. RTS / CTS 둘 다 의미없게 된다.

AP와 B 주변의 애들은 Noise를 듣게되어 아무것도 못 듣게 된다.

그런데, AP - A 사이의 애들은 CTS를 듣게 된다.
그럼 A는 데이터 전송을 시작하게 된다. 그런데 B 주변은 CTS를 못들었으니 A가 전송을 시작한것을 알 수 없다.

그럼 B를 포함한 누군가는 데이터를 보내고 싶으니 RTS를 쏴볼것이다.

그럼 충돌이 난다.. 엄청난 크기의 A가 보내는데 B가 작은 RTS하나 보내서 그 A의 데이터가 싹 다 날아가게 된다.

그럼 이후의 상황은, ACK가 A에게 오지 않았으니 다시 재전송하게 된다.

결국은 **이런 경쟁의 연속**이다.
MAC레이어에서 채널을 차지하기 위한 경쟁이 계속 일어난다.

그러면서 Random Backoff를 계속 하게되서 지연된다..

A,B가 CTS를 통해 합의가 끝나서 A가 데이터를 보내다가, 새로운 X가 들어온다면?

X는 CTS를 받은적이 없으니, RTS를 보내게 되고 이것은 또 충돌을 야기한다.

그냥~ 쉽게 생각해서, ACK를 못받으면 재전송을 하는데, 근데 저런 충돌이 일어나면? 재전송의 무한 반복이 일어난다고 생각하면 된다.

근데 이것에 관해 Standard에서 정해놓은게 있는데, 재전송은 `7`번까지만 한다는 것이다.

이후에는 그 프레임을 포기하고 다음 프레임으로 넘어가라고 한다.

그럼 그 프레임은 평생 재전송이 안되는건가? 냐면 그렇지않다.

나중에 돌고돌아서 다시 TCP에서 프레임이 내려올 것이다.

...

AP는 참 특이한데, AP의 왼쪽은 무선 / 오른쪽은 유선으로, 무선과 유선에 걸쳐있다.

왼쪽은 CSMA/CA , 오른쪽은 CSMA/CD 프로토콜을 사용한다.

그리고 AP는 기본적으로 Link layer 디바이스라서 패킷관련을 처리할 수 없다.

우리가 사용하는 와이파이 네트워크 구조는, AP가 존재하고 우리가 AP를 통해 네트워크로 접근하는 구조이다.

이때, 주변에 AP가 많이 존재하는데 그 중 우리는 어떻게 AP를 선택하게될까?

AP가 주기적으로 broadcasting을 해서 `beacon`프레임을 주변 호스트에게 알리게 되고, 그것을 바탕으로 어디에 접속할것인지 결정하게 된다.

beacon 프레임에는 (AP이름,AP MAC주소,인증정보)를 포함하고있다.

Wi-Fi에서 사용하는 주파수 대역은 2.4Ghz인데, 이건 `unlicense` 대역이라고 해서, 허가 없이 자유롭게 사용할 수 있는 대역이다.

그래서 Wi-Fi 기능이 있는 기기들은 대부분 저 대역을 사용한다.

그런데, 실제로 저 대역 전체를 쓰는것이 아니라, 11개의 서브 채널로 이루어져있어서
그 중 1개를 선택하여 사용하는 방식을 택한다.

이 채널들이 서로 `Overlap`이 안된다면 간섭이 일어나지 않는다.

AP1은 3번, AP2는 11번 채널을 선택했다고 하고, 이 2개가 서로 Overlapping이 일어나지 않는 대역이라고 한다면, AP1에 연결된 호스트와 AP2에 연결된 호스트들은 서로 충돌이 일어나지 않는다.

`Collision domain`이 분리되어있다는 말이다.

그런데 만약, 서로 Overlap되는 도메인을 사용했다면, 통신 시 간섭이 일어나게 된다.

이런 경우, `CSMA/CA` + `RTS/CTS` 가 해결해준다.

![](https://velog.velcdn.com/images/sujipark2009/post/cd967310-ffd2-4914-880d-e098d7a37a18/image.png)

이 Wi-Fi 프레임을 살펴보자.

눈에띄는건, Address 필드가 4개라는 건데 마지막 필드는 무시해도 된다.

Address 1,2,3이 쓰이는데,

Address 2 : 이 프레임을 전송하는 인터페이스의 MAC주소

Address 1 : 이 프레임을 받는 인터페이스의 MAC 주소

Address 3 : DATA에 담긴 IP패킷을 처리할 라우터의 MAC주소

![](https://velog.velcdn.com/images/sujipark2009/post/3a4a6c9c-5e6f-47d1-a306-d1cf4564d9a3/image.png)

그림의 H1이 라우터를 통해 패킷을 보낼건데, H1이 만든 패킷을 프레임에 담아서 보내야 한다.

가장 주의깊게 봐야할 디바이스는 AP인데,

AP가 특별한 이유는, AP의 왼쪽은 무선, 오른쪽은 유선(이더넷)이기 때문이다.

왼쪽은 Wi-Fi Frame, 오른쪽은 Ethernet Frame을 쓴다는 말이다.

양쪽의 MAC Protocol이 다른 상황이다.

![](https://velog.velcdn.com/images/sujipark2009/post/3e416c8e-e05e-4b34-b989-bb6d635d477e/image.png)

왼쪽의 Wi-Fi 호스트들 입장에서는 MAC주소가 보인다.

그런데 오른쪽은 스위치와 같다. 저긴 MAC 주소가 없다.

인터넷 세상에서 보면 저쪽은 그냥 스위치로 보인다.
라우터 입장에서 보면, 라우터 옆에는 그냥 H1이 있는 것이다.

라우터는 H1 이 무선,유선인지 모르고 저 선이 연결된 곳으로 가보면 그냥 H1이 있다~ 는 것만 안다.

![](https://velog.velcdn.com/images/sujipark2009/post/2eda725d-7b50-4240-b2e7-591dcaa6df24/image.png)

H1이 보내는 프레임은 다음과 같이 생겼는데

address 2 : H1의 MAC주소

address 1 : 이걸 받은 AP의 MAC주소

address 3 : 라우터의 MAC주소

AP는 이걸 받아서 이더넷 프레임으로 바꾼다.

![](https://velog.velcdn.com/images/sujipark2009/post/6010bbf7-35d2-4eac-923a-8e56f8f66f94/image.png)

여기서 주목할 점은, Source Address가 AP가 아니라 H1이라는 것이다.

약간 스위치랑 비슷한 느낌이다.

라우터는 이걸 받아서 IP패킷을 열어보고 꺼내서 Forwarding 테이블을 참고하여 다음 목적지로 전송하게 된다.

아직 이해가 어려운건.. 왜 주소필드가 3개냐는 것인데

그냥 Source랑 Dest만 있으면 되지않을까?

2개로 해보자.

Source : H1의 MAC
Dest : AP의 MAC or 라우터의 MAC 둘 중 하나.

1. Dest가 AP의 MAC이라고 해보자.

그럼 이 프레임을 AP가 받고, 그 다음 AP는 뭘 할까?

AP는 Link layer device여서 네트워크 관련 기능이 없다. 패킷을 받긴 받는데, 데이터를 꺼내서 IP 패킷을 본다고 해도 AP는 이 패킷을 이해할수가 없다.
그래서 진행이 안된다.

프레임의 DATA부분에는 IP 패킷이 있을텐데, 그 패킷의 Source와 Dest에는 아마
Source : H1의 IP / Dest : 구글IP 이런식으로 적혀있을텐데, AP는 이걸 이해할수 없다.

2. 라우터의 MAC이라고 해보자.

H1에서 프레임을 쐈는데, 라우터가 안보인다.. 그래서 아무도 이 패킷 프레임을 받을 수 없다.

그래서 필드가 3개인 것이다.

Q. AP에서 라우터로 보내는 프레임의 Source는 왜 H1일까?

A. AP의 오른쪽은 **스위치**같은거라, MAC주소가 없기 때문이다.

AP의 무선쪽(왼쪽)에는 MAC주소가 있지만, 유선쪽(오른쪽)에는 MAC주소가 없다.
그래서 라우터 입장에서는 AP는 그냥 스위치다. MAC주소도 없고, 라우터는 AP를 H1이라고 생각한다.

이제 라우터가 받으면 다시 보낼 수 있겠지?

구글로 갔다가 돌아오는 패킷의 Source : 구글 , Dest : H1의 IP 일 것이다.

이걸 담은 프레임이 라우터로 오고, 라우터는 다시 이걸 프레임으로 만들어서 보낼건데
그때 그 프레임의 Source : 라우터의 MAC / Dest : H1의 MAC 일 것이다.

라우터는 이쪽으로가면 H1이 있는거만 아니까.

이제 이 프레임이 다시 AP로 와서 나갈때는,

address 1(받는사람) : H1의 MAC주소

address 2(보내는 사람) : AP의 MAC주소

address 3 : 라우터의 MAC주소

이런식으로, H1이 프레임을 보낼 때 3개의 필드를 쓴다고 알아두자.

AP의 MAC주소는 어떻게 안다했다? => AP가 주기적으로 **beacon 메시지**를 브로드캐스팅 한다고 했다.

**근데, 라우터의 MAC주소는 어떻게 알까?**

내가 카페에 가서 노트북을 열고 Wi-Fi를 켰다고 해보자.

그러면 beacon 메시지를 받게 되면서 주변 AP를 인식하게 된다.

근데 중요한건, 내가 누구인지 모른다는 것이다. 나의 MAC주소나 IP주소를 모른다.

그래서 무조건 내 자신의 IP를 알아야하니까, DHCP를 통해 내 IP주소,Subnet Mask,Gateway Router IP, Local DNS Server 를 알아와야 한다.

DHCP Request를 보내야하니.. 그 request를 위한 프레임을 만들어야 한다.

주소 2번째는 H1이고, 1번째는 AP이다. 3번째 주소는 모르니까.. Broadcasting을 해야한다.(FF-FF-FF-FF-FF-FF)

이 프레임의 DATA부분에는 아마, Source : ??? / Dest : 255.255.255.255 이렇게 들어있을 것이다.

이렇게 나간 프레임이 AP에 도달하고, AP에서는 이걸 다시 이더넷 프레임으로 재조립해서 전송하게 되는데,

이때 Source : H1의 MAC , Dest : Broadcast 인 프레임이 담기는 것이다.

이제 이 정보가 네트워크 전체에 퍼지게 되고, DHCP가 이걸 받아서 Source : DHCP의 MAC, Dest : Broadcast가 된다.

그래서 H1은 저 4가지 정보(IP,서브넷 마스크,Gateway 라우터 IP,Local DNS Server IP) 를 알게된다.

근데 애초에 이 과정은, **라우터의 MAC주소**를 알려고 시작한것이다..

그래서 H1은 ARP 테이블을 참조해서 IP-MAC 정보를 찾는다. 거기에 없으면 ARP Request를 날려서 라우터의 MAC주소를 찾아오게된다.

그 ARP요청의 address3은 또 Broadcast일것이고 IP Source : H1 / Dest : Google IP 가 될 것이다.

이런 방식으로 Gateway 라우터의 MAC주소를 알게된다...

근데 사실 DHCP를 갔다가 오면 라우터의 MAC주소를 알게 되서 ARP Request가 필요없긴 하다.

..

우리가 흔히 보는 AP는 `공유기` 인데, 그건 사실 라우터랑 합처져서 더 스마트한 디바이스이다. 거기에는 Application Layer까지 있다.
그래서 address 1과 address 3가 동일할것이다.

..

#### Mobility within Same subnet

---

![](https://velog.velcdn.com/images/sujipark2009/post/cecf5b1d-120b-4ac9-a8a1-f72ba8c4db39/image.png)

내가 Wi-Fi를 연결해서 영화를 보다가 이동하게 되면서 Wi-Fi가ㅏ 바뀌게 된다면 그 연결이 끊길까 안끊길까?

이 질문이 `Mobility`와 관련된 질문이다.

`연결` 이라는건 뭘까?
이건 TCP에서 이야기했었는데, 두 Client사이의 TCP Connection이다.

정확히 네트워크 관점에서 본다면, 소켓과 소켓사이의 유일한 연결을 말하는 것이다.

그런데 그 TCP연결이 수만개가 있을건데 그 연결을 어떻게 인덱싱 하는가?

(Source IP,Dest IP,Source Port,Dest Port) 이 4가지(4-tupule)을 가지고 인덱싱한다고 했다.

전세계 TCP연결을 보면, 저 4가지 정보가 같은게 하나도 없다!

저 4개중에 하나라도 바뀐다면, **똑같은 Connection**이 아닌것이다.

내가 웹 브라우저(Client)이고, Youtube가 Server라고 해보면

Youtube의 IP,Port는 보통 안변하는데 나의 IP,Port는 변할 수 있다.

내가 가만히 앉아서 Youtube를 보는데 내 IP/Port가 변할일은 없다.
근데 내가 이제 옆반으로 이동할 때 연결이 끊기냐 안끊기냐는, **내 IP/Port가 변하냐 안변하냐**로 판단할 수 있다.

이제 질문이 바뀌게 되는 것이다.

같은 **서브넷**에서 이동을 하게된다면, IP/Port는 변하지 않으니 Switch Table만
변경을 해주면 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/38daf181-2e8a-4c03-8826-f7cbb858b97f/image.png)

왼쪽 서브넷에서 오른쪽 서브넷으로 H1이 이동했다고 해보자.

아마 기존에 Youtube에서 H1으로 날아오는 패킷이 Source : Youtube / Dest : H1이였고, 이게 라우터에 도달하면 H1에게 보냈을 것이다.

라우터가 하는일은, 목적지의 주소를 보고 Forwarding 테이블을 찾아보면서 Dest에 해당하는 Next Hop을 결정하는 일이었다.

거기 보면 아마 (Dest,Next) : H1,H1 이렇게 되어있었을 것이다.

이 프레임을 보면, Source : 라우터의 MAC주소 / Dest : H1의 MAC주소 이런식일것이다.

이 프레임을 스위치가 받아서 원래는 왼쪽으로 보내던것을 이제는 오른쪽으로 보내야하는 것이다.

그렇다면, 기존에 스위치가 참조하고있던 Switch Table의 Outgoing Port를 변경해줘야 한다.

기존에 H1 MAC : Port0 이런 정보를 H1 : Port1 이런식으로 바꿔줘야 하는데,
이건 `Self-learning`을 통해 변경해야한다.

H1이 이동하면서 Dummy Frame을 라우터에게 보낼 때 스위치가 Self-learning을 해서 Port변경을 감지하게 된다.

..

하지만 만약에 이동한 AP가 **다른 서브넷**에 있는 AP라면, 이 경우는 IP가 변경되는 것이기때문에 연결이 끊어지고 새로 맺어지는 과정이 필요하다.

### 로드밸런서가 무엇인가요?

---

![](https://velog.velcdn.com/images/sujipark2009/post/e7d3aa73-6ce6-47ce-a3f5-b030677e9629/image.png)

로드밸런서(Load Balancer)는 클라이언트와 서버 그룹 사이에 위치해 서버에 가해지는 트래픽을 여러 대의 서버에 고르게 분배하여 특정 서버의 부하를 덜어준다.

서버가 하나인데 많은 트래픽이 몰릴 경우 부하를 감당하지 못하고, 서버가 다운되어 서비스가 작동을 멈출 수 있다. 이런 문제를 해결하기 위해 Scale up과 Scale out방식 중 하나를 이용해 해결한다.

![](https://velog.velcdn.com/images/sujipark2009/post/d84a1eb2-94f6-45f2-b58f-101ec1ab4be9/image.png)

**로드밸런싱의 이점**

**애플리케이션 가용성**

서버 장애 또는 유지 관리로 인해 애플리케이션 가동 중지 시간이 늘어 방문자가 애플리케이션을 사용할 수 없게 될 수 있다.
로드밸런서는 서버 문제를 자동으로 감지하고 클라이언트 트래픽을 사용 가능한 서버로 리다이렉션 해준다.

로드밸런싱을 사용하여,

- 애플리케이션 가동 중지 없이 애플리케이션 서버 유지 관리 및 업그레이드실행
- 백업 사이트에 자동 재해 복구 제공
- 상태확인을 수행하고 가동 중지를 유발할 수 있는 문제 방지

를 더 쉽게 수행할 수 있다.

**애플리케이션 확장성**

로드밸런서를 사용하여 여러 서버 간에 네트워크 트래픽을 지능적으로 전달할 수 있다.
로드 밸런싱이 다음을 수행하므로 애플리케이션에서 수천 개의 클라이언트 요청을 처리할 수 있다.

- 한 서버에서 트래픽 병목 현상 방지
- 필요한 경우 다른 서버를 추가하거나 제거할 수 있도록 애플리케이션 트래픽을 예측

**애플리케이션 보안**

로드 밸런서에는 인터넷 애플리케이션에 또 다른 보안 계층을 추가할 수 있는 보안 기능이 내장되어 있다. 공격자가 서버 장애를 일으키는 수백만 개의 동시 요청으로 애플리케이션 서버를 가득 채우는 분산 서비스 거부 공격을 처리하는 데 유용한 도구이다.

- 트래픽 모니터링 및 악성 콘텐츠 차단
- 공격 트래픽을 여러 백엔드 서버로 자동으로 리다이렉션 하여 영향 최소화
- 추가 보안을 위해 네트워크 방화벽 그룹을 통해 트래픽 라우팅

**애플리케이션 성능**

로드밸런서는 응답 시간을 늘리고 네트워크 지연 시간을 줄여 애플리케이션 성능을 향상시킨다. 다음과 같은 몇 가지 중요한 태스크를 수행한다.

- 서버 간에 로드를 균등하게 배퐇여 애플리케이션 성능 향상
- 클라이언트 요청을 지리적으로 더 가까운 서버로 리다이렉션하여 지연 시간 단축
- 물리적 및 가상 컴퓨팅 리소스의 신뢰성 및 성능 보장

#### L4 로드밸런서와, L7로드밸런서의 차이에 대해 설명해 주세요.

---

**L4 Load Balancer** 는 **IP,PORT**를 기준으로 스케줄링 알고리즘을 통해 부하를 분산한다. 클라이언트에서 로드 밸런서로 요청을 보냈을 때 최적의 서버로 요청을 전송하고 결과를 클라이언트에게 준다.

**L7 Load Balancer**는 L7 위에서 동작하기 때문에, IP,PORT 이외에도 **URI,Payload,Http Header,Cookie** 등의 내용을 기준으로 부하를 분산한다.
그래서 콘텐트 기반 스위칭이라고도 한다.

L4의 로드밸런서가 단지 부하를 분산시키는 것이라면, L7 로드밸런서는 요청의 세부적인 사항을 두고 결제만 담당하는 서버, 회원가입만을 담당하는 서버 등으로 분리해서 가볍고 작은 단위로 여러 개의 서비스를 운영하고 요청을 각각의 서버에 분산할 수 있다.

또한 L7 로드밸런서는 L4 로드밸런서와는 다르게 데이터를 분석해서 처리가 가능하기 때문에 악의적이거나 비정상적인 콘텐츠를 감지해 보안 지점을 구축할 수 있는 장점이 있고, 그 만큼 자원소모가 크다는 단점이 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/e90f3285-e3be-4d25-b1fd-af995f1969af/image.png)

![](https://velog.velcdn.com/images/sujipark2009/post/8723ecad-24bc-4b27-a11d-09a908cbbb77/image.png)

L4 로드밸런서의 장점은 처리 속도가 빠르다는 것이다. 패킷의 헤더정보만을 이용하기 때문에 빠른 응답 시간을 제공한다.

단점은 애플리케이션 계층의 정보를 활용하지 못해 기능 및 유연성이 제한적이라는 점이다. 온라인 게임 / 스트리밍 서비스 등 실시간 트래픽 처리가 중요한 서비스에 적합하다.

L7 로드 밸런서의 장점은 다양한 기능 및 유연성을 제공한다는 것이다. 요청 내용을 분석하여 특정 요청을 특정 서버로 전달하거나, 캐싱 및 압축 등의 다양한 기능을 구현할 수 있다.

단점은 처리 속도가 상대적으로 느리다는 점이다. 패킷의 애플리케이션 계층정보를 분석해야 하기 때문에 L4 로드밸런서보다 처리 시간이 더 걸린다.
웹 서비스, API 게이트웨이, CDN 등 애플리케이션 레벨의 로드밸런싱이 필요한 서비스에 적합하다.

#### 로드밸런서 알고리즘에 대해 설명해주세요.

---

로드밸런싱에는 여러 알고리즘이 사용된다.

가장 흔한 알고리즘은 **라운드 로빈(Round Robin)**, **가중치 분배(Weighted Distribution)**, **최소 연결(Least Connections)** 등이다.

각 알고리즘은 서로 다른 목적과 케이스에 적합하므로, 사용할 로드밸런서의 유형을 잘 선택해야 한다.

1. 정적 로드 밸런싱

- **라운드 로빈 방식**

클라이언트의 요청을 여러 대의 서버에 순차적으로 분배하는 방식이다. 클라이언트의 요청을 순서대로 분배하기 때문에 서버들이 동일 스펙을 가지고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우 활용하기 적합하다.

A,B,C 서버를 가지고 있을경우, A -> B -> C -> A 순서대로 순회한다.

- **가중치 기반 라운드 로빈 방식**

각각의 서버마다 가중치(Weighted)를 매기고 가중치가 높은 서버에 클라이언트의 요청을 먼저 배분한다. 여러 서버가 같은 사양이 아니고, 특정 서버의 스펙이 더 좋은 경우 해당 서버의 가중치를 높게 매겨 트래픽 처리량을 늘릴 수 있다.

- **IP 해시 방식**

IP 해시 방식에서 로드밸런서는 클라이언트 IP 주소에 대해 해싱이라고 하는 수학적인 계산을 수행한다. 클라이언트 IP 주소를 숫자로 변환한 다음 개별 서버에 매핑한다.
사용자 IP를 해싱하여 부하를 분산하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다.

2. 동적 로드 밸런싱

- **최소 연결 방법**

최소 연결 방법에서 로드밸런서는 활성 연결이 가장 적은 서버를 확인하고 해당 서버로 트래픽을 전송한다. 이 방법에서는 모든 연결에 모든 서버에 대해 동일한 처리 능력이 필요하다고 가정

- **최소 응답 시간 방법**

서버의 현재 연결 상태와 응답 시간을 모두 고려하여, 가장 짧은 응답 시간을 보내는 서버로 트래픽을 할당한다. 각 서버의 가용가능한 리소스와 성능,처리 중인 데이터양 등이 상이할 경우 적합하다.

**AWS 로드밸런서 유형**

![](https://velog.velcdn.com/images/sujipark2009/post/0166938d-b317-40a3-95d1-dddb2c0e3c7b/image.png)

1. ALB(Application Load Balancer)

> 가장 많이 사용되는 로드밸런서(가장 똑똑하다)

ALB는 HTTP 헤더 또는 SSL 세션 ID와 같은 요청 컨텐츠를 확인하여 트래픽을 리다이렉션한다.

- HTTP/HTTPS를 지원한다
- Layer 7에서 동작
- 고급 라우팅 기능을 지원

경로 기반 라우팅,호스트 기반 라우팅, URL 쿼리 문자열에 따른 라우팅

- (Docker) 컨테이너화된 애플리케이션과의 통합을 용이하게 한다.
- 고정 IP 주소(Elastic IP)를 사용할 수 있다.
- Sticky Session 사용 가능

ALB는 IP주소 + 포트번호 + 패킷 내용을 보고 스위칭하게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/213aed3a-858d-47e9-bddc-4d231b76818e/image.png)

- 인스턴스에 대한 연결이 로드 밸런서에서 설정되므로 웹 서버 액세스 로그에는 로드 밸런서의 IP주소가 캡쳐된다.

이를 위해 X-Forwarded-For 헤더를 통해 실제 클라이언트의 IP를 전달할 수 있도록 한다.

**Host and Path Based Routing 기능**

![](https://velog.velcdn.com/images/sujipark2009/post/12c601b4-6fa7-4fad-921e-6d981297d04c/image.png)

- 호스트 기반

클라이언트가 요청한 접속 URL의 도메인에 따라 라우팅할 수 있는 기능.
예를 들어, 클라이언트의 접속 URL이 "http://www1.example.com" 일 경우 웹서버1에 접속하게하고, http://www2.example.com" 일 경우 웹서버 2에 접속하게 할 수 있다.

- 경로 기반

경로 기반 라우팅이란, 클라이언트가 요청한 접속 URL의 경로에 따라 라우팅할 수 있는 기능.

예를 들어, 클라이언트의 접속 URL이 "http://www.exmaple.com/web1" 일 경우 웹서버 1에 접속하게 하고, "http://www.example.com/web2" 일 경우 웹서버 2에 접속하게 할 수 있다.

- URL Query 문자열 기반

클라이언트가 요청한 접속 URL의 쿼리 문자열에 따라 라우팅할 수 있는 기능.
URL 쿼리 문자열은 브라우저가 웹 서버에 전송하는 데이터를 URL에 표현한 것이다.

예를들어 URL이 "http://www.example.com/web?lang=kr" 일경우 lang=kr이 URL 쿼리 문자열에 해당한다.

클라이언트의 접속 URL이 http://example.com/web?lang=kr 일 경우 한국어 사이트로 접속하고, ...lang=en 인 경우 영어사이트로 접속하게 할 수 있다.

**Sticky Session 기능**

Cookie의 유효시간 동안에 클라이언트가 **동일한 백엔드 인스턴스(서버)** 에 접근할 수 있도록 하는 기능.
이를 통해 클라이언트는 같은 인스턴스에 연결된 상태를 유지하게 되며, 세션 상태를 인스턴스 별로 저장해야 하는 애플리케이션에 유용하다.

![](https://velog.velcdn.com/images/sujipark2009/post/6cc4b454-441d-445a-8528-92c0be49d80c/image.png)

예시

아마존 쇼핑사이트가 2개의 백엔드 서버와 로드밸런서로 운영 중이다.
유저가 장바구니에 상품을 저장시켰다. (한쪽의 백엔드 서버를 이용)
근데 갑자기 로드밸런스가 다른 백엔드 서버로 트래픽을 이동시키면 상태(세션) 정보가 사라지기 때문에 장바구니에 있던 상품들은 사라지게 될 것이다. 이걸 방지하는 것이 "Sticky Session"이다.

**Listener Rules**

Listener Rules는 수신한 요청을 어떻게 처리할지에 대한 규칙을 설정한 기능이다.
위에서 설명한 호스트/경로 기반 라우팅은 Listener Rules를 통해서 라우팅한다.

- 요청의 **경로(Path)** 또는 **호스트 이름(Host)** 을 기준으로 규칙/조건을 설정하여, 특정 URL로 들어오는 요청을 다른 타겟 그룹으로 라우팅할 수 있다.

- **헤더** 또는 **쿼리 문자열** 의 내용에 따라 요청을 다르게 처리할수도 있다.
- HTTP로 들어오는 요청을 HTTPS로 리다이렉트 할 수 있다.

2. NLB(Network Load Balancer)
   > 대규모 네트워크 트래픽에 특화되어 있어 빠른 응답 속도를 보여주는 로드밸런서

- TCP,UDP,TLS를 지원한다
- Layer 4에서 동작
- 고성능, 상당히 낮은 Latency으로 대량 트래픽을 처리할 수 있다.
- 고정 IP주소(Elastic IP)를 사용할 수 있다
  이로써 클라이언트는 항상 동일한 IP 주소로 연결할 수 있다(DNS Name과 IP 주소 둘 다 사용 가능)

ALB는 고정 IP 주소를 사용할 수 없다.

- Sticky Session 사용 불가

HTTP가 아닌 하위 Layer인 TCP Layer에서 처리하므로 HTTP 헤더를 해석하지 못한다.

NLB는 IP + 포트번호를 보고 스위칭한다.

#### 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해주세요.

---

DNS는 도메인 이름을 IP주소로 변환하는 기술이다.

대용량 서비스를 운영하려면 부하 분산은 필수다. 대용량 트래픽을 장애없이 처리하려면 여러 대의 서버에 적절한 트래픽을 분배해야 한다. 단지 몇 개의 노드만 있다면 `DNS 라운드 로빈 방식` 이 합리적이다. **로드 밸런서 자체는 비용이 높고 불필요한 복잡함을 증가**시킬 수 있기 때문이다.

DNS에서는 하나의 도메인 이름을 라운드 로빈 방식으로 여러 개의 IP 주소로 변환한다면, 이것만으로 **쉽게 부하 분산이 가능** 하다.

하지만 여기에는 두 가지 단점이 존재하는데,

1. 대부분의 클라이언트에서는 **DNS 서버의 부하를 줄이고 성능을 향상** 시키기 위해 일정 시간 동안 캐싱하기 때문에 부하 분산이 균등하게 되지 않는다.

2. 특정 서버에 장애가 발생하더라도 **장애 여부가 감지되지 않아 서비스에서 해당 서버를 제거할 수 없다**. 이것을 보안하기 위해 health check로 장애를 감지하여 DNS 서버에서 제거할 수 있지만, 모든 DNS 서버에 적용되는 데에는 상당한 시간이 소요될 뿐만 아니라 클라이언트의 캐싱 때문에 서비스에서 바로 제거되지 않는다.

그렇기 때문에 대규모 시스템에서는 상황에 따라 적절한 로드밸런싱 알고리즘과 스케쥴링이 사용되고 있다.

### XSS에 대해서 설명해주세요.

---

XSS(Cross-Site-Scripting, 크로스사이트 스크립팅)은 공격자가 입력한 악성스크립트가 사용자 측에서 응답하는 취약점으로, 사용자의 입력값에 대한 검증이 미흡하거나 출력 시 필터링 되지 않을 경우 발생한다. 쿠키값 또는 세션 등 사용자의 정보를 탈취하건 피싱 사이트로의 접근 유도 등 사용자에게 직접적인 피해를 줄 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/a6379dc1-77c4-467f-8806-9e6f8ba2a658/image.png)

사용자의 입력값을 받는 모든 곳에서 발생할 수 있으며, 웹 서버 사용자에게 직접적인 영향을 미칠 수 있는 공격 기법이다. 또한 게시물 또는 URL에 포함된 악성스크립트가 동작하여 발생하는 취약점이기 때문에 불특정 다수를 대상으로 공격을 시도할 수 있다.

크게 3가지로 분류할 수 있으며,

1. **Stored XSS(저장형 크로스사이트 스크립팅)**

공격자의 악성스크립트가 DB에 저장되고 이 값을 출력하는 페이지에서 피해가 발생하는 취약점이다.

공격자는 악성스크립트가 포함된 게시물을 작성하여 게시판 등 사용자가 접근할 수 있는 페이지에 업로드한다.
이때 사용자가 악성스크립트가 포함된 게시물을 요청하면, 공격자가 삽입한 악성스크립트가 사용자 측에서 동작하게 된다.

공격자의 악성스크립트가 서버에 저장되어 불특정 다수를 대상으로 공격에 이용될 수 있어서 `Reflected XSS` 보다 공격 대상의 범위가 훨씬 크다.

![](https://velog.velcdn.com/images/sujipark2009/post/a7a1e8fc-68a3-44aa-978f-a20f80017f84/image.png)

2. **Reflected XSS(반사형 크로스사이트 스크립팅)**

사용자가 요청한 악성스크립트가 사용자 측에서 반사(Reflected)되어 동작하는 취약점으로, 공격자의 악성스크립트가 DB와 같은 저장소에 별도로 저장되지 않고 사용자의 화면에 즉시 출력되면서 피해가 발생한다.

공격자는 악성스크립트가 포함된 URL을 이메일,메신저 등을 통해 사용자가 클릭할 수 있도록 유도한다.
사용자가 악성스크립트가 삽입된 URL을 클릭하거나 공격자에 의해 악의적으로 조작된 게시물을 클릭했을 때 사용자의 브라우저에서 악성스크립트가 실행된다.

![](https://velog.velcdn.com/images/sujipark2009/post/0b790e3f-4608-48ee-b6b9-184c82081d06/image.png)

![](https://velog.velcdn.com/images/sujipark2009/post/017e19a5-b8a9-44d5-b50d-45cc00370881/image.png)

3. **DOM Based XSS(DOM 기반 크로스사이트 스크립팅)**

공격자의 악성스크립트가 DOM 영역에서 실행됨으로써 서버와의 상호작용 없이 브라우저 자체에서 악성스크립트가 실행되는 취약점이다. DOM 영역에 변화가 생기면 브라우저는 서버로 패킷을 보내지 않고 DOM 영역에서 페이지를 변환시킨다. 따라서 DOM의 일부로 실행되기 때문에 브라우저 자체에서 악성스크립트가 실행된다.

\*DOM(Document Object Model, 문서 객체 모델) 이란?

브라우저가 웹 페이지를 렌더링 하는데 사용하는 모델로, HTML 및 XML 문서에 접근하기 위한 인터페이스이다. 브라우저는 HTML 문서를 읽고 해석한 결과를 DOM 형태로 재구성하여 사용자에게 제공한다.

![](https://velog.velcdn.com/images/sujipark2009/post/1e4d7850-b5b4-4020-9bde-5c22b03c3358/image.png)

![](https://velog.velcdn.com/images/sujipark2009/post/4586cf60-6d67-451d-95ab-e7e6920cbb85/image.png)

Stored XSS와 Reflected XSS는 서버에서 악성스크립트가 실행되고 공격이 이루어지는 반면에 DOM Based XSS는 서버와 상호작용 없이 브라우저에서 악성 스크립트가 실행되고 공격이 이루어진다.

**보안 대책**

XSS 취약점은 공격자가 삽입한 악성스크립트로 인해 발생하기 때문에 입력값 검증을 통해 악성스크립트가 삽입되는 것을 방지해야 하며, 악성스크립트가 입력되어도 동작하지 않도록 출력값을 무효화해야 한다.

입력값 필터링의 경우 DB에 악성스크립트가 저장되는 것을 원천적으로 차단해야 한다.
또한, 악성스크립트가 삽입되어도 동작하지 않도록 출력값을 검증하여 스크립트에 사용되는 특수문자를 HTML Entity로 치환하여 응답하도록 한다.

<문자는 &lt로, >문자는 &gt; " 문자는 &quot; 등 이런식으로 필터링을 걸 수 있고,

게시판과같이 HTML 태그 사용이 필요한 경우에는 WhiteList Filter를 통해 허용할 태그를 선정하여 해당 태그만 허용하는 방식을 적용해야 한다.

#### CSRF랑 XSS는 어떤 차이가 있나요?

---

CSRF(Cross Site Request Forgery)

사용자가 자신의 의지와는 무관하게 침입자가 의도한 행위를 서버에 요청하게 만드는 공격.

XSS가 `사용자가 특정 사이트를 신뢰` 하기 때문에 발생하는 문제라면, CSRF는 `특정 사이트가 사용자를 신뢰` 하기 때문에 발생하는 문제이다.

![](https://velog.velcdn.com/images/sujipark2009/post/24995a04-101c-477a-9a42-63873cab89d4/image.png)

1. 침입자는 서버로 넘어가는 자금 전송에 대한 요청을 조작하려고 한다.
2. 침입자는 하이퍼링크에 자금 전송 요청에 대한 스크립트를 삽입하고 사이트에 로그인할 사람들에게 전송한다.

3. 사용자가 링크를 누르면, 의도치않게 서버로 자금 전송 요청을 보내게 된다.
4. 서버는 **로그인된 사용자의 요청** 이기 때문에 정상적으로 인식하고 전송을 실행하여 침입자에게 돈이 송금된다.

> CSRF의 2가지 조건

1. 사용자가 웹사이트에 로그인 상태여야 한다.
2. 사용자는 조작된 페이지에 방문(접속)해야 한다.

**대응 방안**

1. 요청 헤더(Request header)의 도메인과 일치하는지 `referrer` 속성 검증

같은 도메인에서의 요청이 아니라면 차단한다

예를들어, 내가 bank.com에 로그인을 한 상태로 악의적인 페이지(광고,이메일..)에 접속하게 되었다고 하자.

로그인을 했으니 우선 쿠키안에 bank.com의 세션정보가 담겨있을것이고 만약 악의적인 페이지에서

```
<!DOCTYPE html>
<html>
  <body>
    <!-- 자동으로 특정 계좌로 돈을 이체하는 요청을 bank.com 서버에 보냄 -->
    <img src="https://bank.com/transfer?toAccount=mallory123&amount=10000" />
  </body>
</html>

```

이런식으로 사용자 모르게 요청을 보내버릴 수 있다.

GET /transfer?toAccount=mallory123&amount=10000 HTTP/1.1
Host: bank.com
Cookie: sessionId=abc123

이런식으로 요청이 갈 것이다.

여기에다가 만약 Referrer을 넣었으면,

Referer: https://evil.com/

이런 정보가 담겨있을 것이다. 그래서 서버는 이걸 보고 신뢰할 수 있는 도메인이 아니면 무시할 수 있는 것이다.

2. `CSRF Token` 사용

- 랜덤한 UUID와 같은 임의의 난수를 세션에 저장해두고 해당 난수가 전달되지 않으면 요청을 거부

3. `CAPTCHA`

#### XSS는 프론트엔드에서만 막을 수 있나요?

---

#### L3 Switch와 Router의 차이에 대해 설명해주세요.

---

초기에는 차이점이 있었으나.. 현재로써는 거의 없다고 한다.

개념적으로 존재하는 차이만 보자면,

스위치는 HW기반, Router는 SW기반

스위치는 NAT기능 없음, Router는 있음

스위치는 서브넷 간 연결, Router는 네트워크 간 연결...

#### API Gateway

---
