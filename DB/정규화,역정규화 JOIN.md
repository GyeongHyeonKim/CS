### 정규화가 무엇인가요?
---

- DB 설계 과정에서 데이터 중복을 제거하고 무결성을 유지하기 위해 테이블을 체계적으로 나누는 작업

#### 정규화의 목적은 무엇인가요?
---

- 중복 제거

- 데이터 무결성 유지 -> 이상 현상 방지

- 유지보수성 향상

- 데이터 관계 명확화 -> 쿼리 작성이 쉬워짐


#### 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해주세요.
---

- 데이터의 중복으로 인해 발생가능한 부작용

`삽입 이상`

- 불필요한 데이터의 삽입

데이터를 삽입하는 데 필요없는 속성도 함께 추가해야 함

![](https://velog.velcdn.com/images/sujipark2009/post/c8662bf7-fba5-479c-af47-366515231b16/image.png)

해당 테이블에 1,2,3번 컬럼의 값만 테이블에 넣고싶은데 테이블이 4개의 컬럼으로 
이루어져 있기 때문에 마지막 `필드 값을 무엇으로 해야할지 결정하지 못하는 것`이 삽입 이상이다. 그렇기 때문에 반강제적으로 `NULL` 값을 삽입해야 한다.

- 삽입 불가능

일부 정보로는 모든 열을 채울 수 없어 삽입이 불가능한 상황

`갱신 이상`

- 수정 누락

중복된 데이터 중 일부만 수정하여 데이터 불일치

![](https://velog.velcdn.com/images/sujipark2009/post/008f42e4-dd3b-4d09-9512-2f00f119c055/image.png)

첫 번째 튜플의 이름을 김사랑 -> 김소연으로 업데이트 하면 세 번째 튜플의 내용과 불일치 하게 된다.

`삭제 이상`

- 데이터를 삭제하는 중 의도하지 않은 것이 함께 삭제되는 것

![](https://velog.velcdn.com/images/sujipark2009/post/5bab4bf4-3818-426b-b451-1e92a09bd2a3/image.png)

운영체제라는 정보만 삭제하고 싶은데, 이것을 지우려면 지우기 싶지 않은 필드(이름,성적)들의 정보도 같이 지워져야 한다.


#### 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
---

`제1정규형(1NF)`

- 모든 열이 원자 값을 가지도록 테이블 분리

**원자값**

- 더 이상 분해가 불가능한 최소 단위의 값으로 이루어진 데이터

- 검색 성능 향상을 위해 필요함

검색 시 조건이 정확하게 일치할 경우 반환
인덱스 크기를 줄여 검색 속도 향상
비원자값은 복잡한 조건 필요

**조건**

- 테이블의 모든 행과 열이 단일 값만 가져야 함

- 각 열은 동일한 데이터 유형

**정규화 결과**

- 반복 데이터가 행으로 분리

**예시**

- 전화번호를 국번과 나머지 번호로 구분해 저장

`제2정규형(2NF)`

- 완전 함수 종속을 만족하기 위해 부분 함수 종속을 제거하여 테이블을 분리하는 것

**조건**

- 1NF 만족

- 기본키의 `부분집합`에 의존하는 속성을 제거

**정규화 전의 문제점**

- 데이터 중복이 많고, 삽입/수정 이상이 발생

**예시**

- 학생 ID,과목 ID,학생명,과목명

학생명과 과목명이 학생ID와 과목ID의 부분종속

학생 테이블과 과목 테이블, 학생-과목 관계 테이블로 분리

`제3정규형(3NF)`

- 이행적 종속을 없애도록 테이블 분리

이행적 종속이란, A->B, B->C 일때 A->C 인 관계를 말한다

**조건**

- 2NF 만족

- 기본키가 아닌 속성이 다른 비 기본키 속성을 결정하지 않아야 함

**정규화 전의 문제점**

- 수정 시 이상 현상

**예시**

- 직원ID,부서ID,부서명

부서명 -> 부서ID -> 직원ID

직원 테이블, 부서 테이블로 분리

`BCNF`

- 제3정규형을 강화하여, 모든 결정자가 후보키가 되도록 보장

결정자란, 어떤 컬럼의 값을 결정하는 컬럼

**조건**

- 3NF 만족

- 모든 함수 종속의 결정자가 후보키여야 함

**예시**

- 과목 ID, 교수 ID, 교수명

### 함수적 종속성이란 무엇인가요?
---

- 데이터베이스에서 특정 열 간의 관계를 나타내는 개념

특정 열이 다른 열의 값을 결정하는 관계


**종류**

`완전 함수적 종속`

- 어떤 속성의 일부 값이 다른 속성에 종속되어 있지 않고, 모든 값이 종속되어 있는 경우

기본 키 전체에 종속

`부분 함수적 종속`

- 기본 키의 일부로 값이 결정

**예시**

- 기본키 : 이름 + 전화번호
- 결정되는 속성 : 학번

`이행적 함수 종속`

- A->B, B->C의 종속관계에서 A->C가 성립하는 경우

**예시**

- 직원 ID -> 부서 ID -> 부서명

#### 역/반정규화란 무엇인가요?
---

- DB 성능을 향상시키기 위해 정규화된 DB의 일부분을 의도적으로 비정규화하는 과정

**필요성**

- 읽기 성능 개선

자주 검색되는 데이터의 경우 조인을 줄일 수 있음

- 복잡한 쿼리 단순화

- 데이터의 입력 및 수정속도 향상

조인이 줄어들어 입력 및 수정 속도 향상

**방법**

- 테이블 통합

분리된 테이블을 다시 합침

- 중복 데이터 추가

자주 조회되는 데이터를 여러 테이블에 중복 저장

- 계산된 값 저장

계산해야 하는 값을 미리 저장하여 실시간 계산을 줄임

- 컬럼 추가

외래 키 대신 직접 참조 데이터를 컬럼으로 추가

**단점**

- 데이터의 중복이 증가하며 공간이 낭비됨

- 무결성 유지가 어려움 -> 데이터 중복으로 인해 모든 위치에서 동일하게 수정을 해야함


### DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.
---

- 두 개 이상의 테이블 데이터를 결합하여 하나의 결과 집합을 생성하는 연산

- 정규화된 테이블에서 데이터 조회

**방식**

`Inner Join`

- 두 테이블에서 공통된 키를 기준으로 일치하는 데이터만 반환

- 가장 일반적으로 사용

`Outer Join`

- 한쪽 또는 양쪽 테이블의 데이터를 모두 포함하며, 일치하지 않는 행은 NULL로 채워 반환

**종류**

Left Join - 왼쪽 테이블의 모든 행을 포함하며, 오른쪽 테이블과 일치하지 않는 데이터는 Null로 채움

Right Join - 오른쪽 테이블의 모든 행을 포함하며, 왼쪽 테이블과 일치하지 않는 데이터는 Null로 채움

Full Join - 양쪽 테이블의 모든 데이터를 포함하며 일치하지 않는 데이터는 Null로 채움

`Cross Join`

- 두 테이블의 모든 행의 조합을 반환

- 결과 행의 수는 두 테이블 행 수를 곱한 값

조건 없이 사용하면 데이터가 많아 비효율적

`Self Join`

- 셀프 조인은 동일한 테이블을 두 번 조인하는 것

- 테이블 내에서 행 간의 관계를 비교하거나, 연결할 때 사용

테이블은 서로 다른 별칭을 두 개의 별도 엔티티처럼 취급

**예시**

- 동일한 테이블 내에서 부서와 관리자 관계를 확인


#### JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
---


- Join 연산은 매우 비용이 크다

두 개 이상의 테이블에서 많은 양의 데이터를 처리하고, 일치하는 행을 찾아야 하기 때문이다.

따라서 여러 최적화 기법을 사용한다

`Join 알고리즘`

**Nested Loops**

- 가장 기본적인 Join 알고리즘

- 두 테이블의 모든 행에 대해 반복을 수행

- O(M*N)

- 작은 테이블에 대해서는 효과적 / 내부 테이블에 인덱스가 있으면 효율적

- 테이블의 크기가 커질수록 비효율적


조인을 할 때 먼저 액세스 되는 테이블을 Driving Table이라 하고 나중에 액세스 되는 테이블을 Driven Table이라고 한다. 

Driving Table은 옵티마이저가 결정하고 자연스레 Driving Table이 아닌 테이블은 Driven Table로 결정된다.

![](https://velog.velcdn.com/images/sujipark2009/post/5405cbb9-4507-4a73-9dab-108ee0a3dfbd/image.png)

```
 for(i=0; i<dept.length; i++) { -- driving table 
    for(j=0; j<emp.length; j++) { -- driven table
       // Search
    } 
}
```

이중 for문과 작동원리가 비슷하다

**Hash Join**

- 두 테이블 중 하나를 메모리에 적합한 크기로 해시 테이블을 만든다

- 다른 테이블을 스캔하면서 해시 테이블의 값과 일치하는 행을 찾는다

- 대용량 테이블에서 효과적이다

Hash Join은 비용 기반 옵티마이저를 사용할 때만 사용될 수 있는 조인 방식이며, `=` 비교를 통한 조인에서만 사용될 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/e816609a-d05a-457c-9c07-d14f6f26b63f/image.png)

1. 둘 중 작은 직합(Build Input)을 읽어 Hash Area에 해시 테이블을 생성한다.

2. 반대쪽 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 Join한다

3. 해시 함수에서 리턴받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다. 

**단점**

- 충분한 메모리 공간이 필요하다
- 조인 키가 해시 가능한 데이터 유형이여야 한다

- 테이블의 크기가 메모리 크기를 초과하는 경우 문제가 발생한다
초과 시 Disk I/O 발생


**Merge Join**

- 두 테이블을 JOIN의 기준이 되는 필드에 대해 정렬한 후, 한 번에 한 행씩 순차적으로 비교

- 정렬된 상태에서 비교하여 효율적

- 범위 조건이나 순차 데이터 처리에 적합

- 정렬되지 않은 데이터 정렬 비용 발생

- 양쪽 데이터 모두 정렬된 상태여야 효율적


조회의 범위가 많을 때 주로 사용하는 조인 방법론이며, 양쪽 테이블을 각각 Access하여 그 결과를 정렬하고 그 정렬한 결과를 차례로 Scan해나가면서 연결고리의 조건으로 Merge하는 방식.

주로 조인 조건 컬럼에 인덱스가 없거나, 출력해야 할 결과 값이 많을 때 사용된다.

```
select /**USER_MERGE(A B) */ A.Color, B.SIZE,...
from TABLE_A A,TABLE_B B
where a.joinkey_a = b.joinkey_b -- join key에 대한 인덱스가 테이블 둘 모두 다 없음
and a.color = 'RED' --인덱스 있음
and b.size = 'MED'; --인덱스 없음

```

위와 같은 쿼리에 color 컬럼에만 인덱스가 있다고 가정하였을 때, `SORT MERGE JOIN`로 이 쿼리가 동작된다면 아래와 같은 프로세스로 동작하게 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/f5e90115-9476-4e11-85fd-9ad1bb20637f/image.png)

먼저 왼쪽과 오른쪽에 있는 TABLE_A와 TABLE_B를 동시에 ACCESS한다.

여기서 COLOR에 인덱스가 걸려있기에 TABLE_A는 인덱스 스캔을 할 것이고, TABLE_B는 테이블 풀 스캔(Full Table Scan)을 하게 된다.

이렇게 조회된 데이터들은 TABLE_A에서 읽은 데이터는 JOINKEY_A를 기준으로, TABLE_B에서 읽은 데이터는 JOINKEY_B를 통해 별도의 공간에서 SORT 작업을 거치게 된다.

두 개의 정렬 작업이 모두 완료되었다면, 정렬한 결과를 차례로 Scan해 나가면서 연결고리의 조건으로 Merge하여 리턴하게 된다.


#### JOIN의 성능도 인덱스 유무의 영향을 받나요?
---


- JOIN 연산의 성능은 인덱스의 유무에 크게 영향을 받는다

인덱스를 적절히 사용하면 데이터베이스에서 테이블 간의 연결을 더 빠르게 수행한다

- JOIN 작업은 두 개 이상의 테이블에서 공통 필드를 기준으로 데이터를 결합한다

인덱스는 이 공통 필드를 기반으로 데이터를 빠르게 찾아주는 역할을 한다.

인덱스가 없는 경우, DBMS는 테이블의 모든 행을 풀 스캔해야하므로 성능이 떨어질 수 있다.

**예시**

테이블 A와 B가 있고 이 두 테이블을 JOIN할 때 공통 필드가 id

이 id 필드에 인덱스를 생성하면 JOIN 작업이 더 빠르게 수행될 수 있음

DBMS가 id 값의 위치를 빠르게 찾을 수 있다.

#### 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
---

- DBMS에서는 쿼리 최적화를 통해 쿼리의 실행 계획을 결정하고 이에 따라 구현 방식이 결정된다.

- 쿼리의 실행 계획을 확인하려면 대부분의 DBMS에서 제공하는 `Explain Plan` 또는 `Execution plan` 기능을 사용

**예시**

MySQL의 경우, EXPLAIN 키워드를 사용하여 쿼리의 실행계획을 확인할 수 있다.

EXPLAIN SELECT * FROM table1 JOIN table2 ON table1.id = table2.id;

실행결과에는 사용된 인덱스, 조인 유형, 예상 행 수 등이 포함된다.

어떤 쿼리가 성능 저하를 일으키는지 파악하고, 쿼리 성능을 향상시키는 데 도움이 될 수 있다.