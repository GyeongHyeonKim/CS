#### 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

---

- DB 테이블에 대한 검색 성능의 속도를 높여주는 자료구조

개체의 레코드를 검색하기 위한 키

- 기본적으로 B-Tree 구조를 이용해 데이터 Index를 수행

DB Engine에 따라 사용할 수 있는 Indexing 방법이 다름

인덱스는 데이터 레코드를 빠르게 접근하기 위해서 <키,포인터> 쌍으로 구성되는 데이터 구조이다.

테이블에 데이터가 저장되는데, 특정한 PK값을 가지는 데이터를 찾기 위해서 매번 접근하는 것은 비효율적이다.

PK값과 해당하는 데이터 row의 주소를 자료구조로 묶어서 저장하는 것이 인덱스이다.
따라서, 인덱스는 **DB의 테이블에 데이터가 많을 때, 검색 속도를 향상시켜주기위해 사용하는 객체이다.**

컬럼을 정렬한 후에 데이터를 빠르게 찾을 수 있도록 도와주는 역할을 한다.
즉, 인덱스의 가장 큰 목적은 대용량 데이터 조회 시 select문의 조회 속도를 향상시키는 것이다.

인덱스로 설정되지 않은 컬럼의 조회는 Full Scan(Table Scan)수행하기 때문에 속도 저하를 가져온다.

하지만, 인덱스를 생성한다고 해서 무조건 좋은것은 아니다.
인덱스를 생성하면 인덱스를 위한 디스크 공간이 필요하고, 인덱스를 가진 테이블에 DML 작업을 할 경우 더 많은 비용과 시간이 필요하다.
때문에 인덱스를 생성 시 해당 테이블의 의도를 정확하게 파악한 후에 상황에 맞게 적절한 컬럼으로 **Clustered Index** 와 **Non-Clustered Index**를 구성해야 한다.

#### Clustered Index와 Non-Clustered Index는 무엇인가요?

---

**Clustered Index**

- 테이블 실제 데이터가 인덱스 구조로 정렬되어 저장
- 각 테이블에 하나만 존재 가능

- 실제 데이터와 같은 무리의 인덱스

![](https://velog.velcdn.com/images/sujipark2009/post/bc4de0a9-4fef-406e-b1bd-97c46bffd8fe/image.png)

실제 데이터가 정렬된 **사전**

![](https://velog.velcdn.com/images/sujipark2009/post/068fd9c4-98c0-4b27-8deb-565f2217e1e5/image.png)

클러스터링 인덱스를 적용하면, id 컬럼을 기준으로 데이터가 정렬이 된다.

![](https://velog.velcdn.com/images/sujipark2009/post/186a3119-0934-40e9-9b51-ef171b276564/image.png)

그리고, 정렬된 데이터를 기준으로 루트 페이지가 생성이 되는데 루트 페이지와 리프 페이지는 **B-Tree 구조로 되어있다.**

![](https://velog.velcdn.com/images/sujipark2009/post/c014e957-8443-43c5-a0ae-36f29ad21a56/image.png)

루트 페이지에 있는 숫자는, 데이터 페이지의 주소를 의미한다.

데이터 페이지는, **실제 데이터가 저장되어있는 페이지를 의미한다.**

여기서, SELECT \* FROM member WHERE id = 7을 날리면,

![](https://velog.velcdn.com/images/sujipark2009/post/243bd155-2093-4142-bfa6-6d46fae0087f/image.png)

7은 루트페이지에서 5와 9 사이에 있기때문에 5로 찾아가서 찾게 된다.

다음은, 클러스터링 인덱스의 특징이다.

![](https://velog.velcdn.com/images/sujipark2009/post/8d12fdba-b52d-4a32-887b-823174112a01/image.png)

PK도 있고 unique + not null 키도 존재한다면 PK가 우선순위를 가지게 된다.

**Non-Clustered Index**

- 데이터와 별개로 저장되는 인덱스
- 포인터를 통해 실제 데이터 찾음

- 실제 데이터와 다른 무리의 별도의 인덱스

실제 데이터 탐색에 도움을 주는 별도의 **찾아보기 페이지**

![](https://velog.velcdn.com/images/sujipark2009/post/e76f0681-6c97-40b2-ab8a-7ea4eae47681/image.png)

이렇게 name 컬럼에 Non-Clustered Index를 걸었다고 해보자.

![](https://velog.velcdn.com/images/sujipark2009/post/50062548-c81a-4b31-af77-884021538cc3/image.png)

Non-Clustered Index는 다음과 같은 구조로 만들어지는데

![](https://velog.velcdn.com/images/sujipark2009/post/703c3025-034b-4184-9d20-ee1b3efbdbc1/image.png)

실제 데이터가 저장된 데이터 페이지는, 어떤 정렬이나 변화가 일어나지 않는다.

그리고 별도의 name 컬럼에 대한 인덱스 페이지가 추가된다.

여기서 인덱스 페이지를 보면, name을 기준으로 정렬되어있음을 알 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/696b39ae-7f6d-4d39-9990-325d0a0036d0/image.png)

1002는 1002번 데이터 페이지를 말하고, #3은 3번째에 있다는 의미이다.

실제 데이터 탐색에 도움을 주는 별도의 **찾아보기 페이지**라는 것은 이런 의미이다.

![](https://velog.velcdn.com/images/sujipark2009/post/8c65e33c-8bdc-444b-8e84-a3cab9a0c2d7/image.png)

논 클러스터링 인덱스의 특징은 다음과 같다.

![](https://velog.velcdn.com/images/sujipark2009/post/c5464e44-3d25-4f79-ab10-06a434b8a818/image.png)

그럼, 클러스터링 인덱스와 논 클러스터링 인덱스를 함께 적용하면 어떻게 되는가?

![](https://velog.velcdn.com/images/sujipark2009/post/cece850b-da0a-4f99-90b0-954922ffeb3e/image.png)

그럼 이렇게 구성되지 않을까? 하고 예상을 할 수 있다.

![](https://velog.velcdn.com/images/sujipark2009/post/4112e77f-77a9-4b11-b472-4eca325f42f5/image.png)

하지만 실제로는 이렇게 적용되어있다.

![](https://velog.velcdn.com/images/sujipark2009/post/65de9f52-efda-4549-afa6-80c056384b32/image.png)

데이터 페이지의 주소값이 아닌, 클러스터링 인덱스가 적용된 id 컬럼의 값이 들어있다.

![](https://velog.velcdn.com/images/sujipark2009/post/059bb3b4-8c68-4f94-9d86-4713e29463fe/image.png)

![](https://velog.velcdn.com/images/sujipark2009/post/e8fc7e18-e458-4f60-94f1-cad4abdff85d/image.png)

그런데, 왜 논 클러스터링 인덱스의 인덱스 페이지에 데이터 페이지의 주소가 바로 적혀있지 않을까?

![](https://velog.velcdn.com/images/sujipark2009/post/c7f2b8cc-d1fd-4a59-9fb8-942414d04840/image.png)

이렇게 구성하면 문제점이 생기기 때문인데,

만약에, 새로운 데이터가 추가가 된다면, 이 예시에서 실제 데이터 페이지에는 페이지 분할이 생기기 때문에

![](https://velog.velcdn.com/images/sujipark2009/post/044a8180-b9c3-42fe-8d25-f361c5e7228d/image.png)

위의 두 곳에서 주소 변경이 이루어져야 하는 문제점이 있다.

그래서 이런식으로 id가 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성되어있다.

클러스터링 인덱스와 논 클러스터링 인덱스를 함께 적용할 경우, 아까 보았던 각각의 속성들이 잘 지켜지지만,

![](https://velog.velcdn.com/images/sujipark2009/post/27bdbef7-f9cb-4cbc-94ea-141c374224f9/image.png)

논 클러스터링 인덱스의 리프 페이지에는 실제 데이터 페이지의 주소가 존재하는게 아니라, 클러스터링 인덱스가 적용된 컬럼의 실제 값이 들어가게 된다.

#### 인덱스의 동작 원리는 무엇인가요?

---

- 데이터 정렬

테이블 특정 열에 대해 정렬된 데이터 구조를 생성

정렬된 상태를 유지하며 검색,삽입,삭제 작업 최적화

- 참조 구조

인덱스는 테이블 실제 데이터와 연결된 포인터를 포함
인덱스를 검색하고 참조를 따라가 데이터를 가져옮

**좋은 시나리오**

- 조건 검색 Where 절
  인덱스를 사용하는 가장 큰 이유

- 정렬 Order by 절
  이미 정렬된 구조이기에 추가 작업 필요 없음

- Min/Max
  레코드의 시작 값과 끝 값을 인덱스로 가져올 수 있음

- 범위 검색
  B+ Tree인 경우

#### 인덱스 알고리즘에는 어떤 것들이 있나요?

---

**B-Tree / B+ Tree 인덱스**

- 가장 널리 사용됨
- RDBMS에서 기본 인덱스 구조

**장점**

- 검색,삽입,삭제가 빠름
- 디스크 I/O 최소화
- 범위 검색 유리

B-Tree를 알아보기위해, Tree부터 알아보자.

**트리(Tree)** 란?

![](https://velog.velcdn.com/images/sujipark2009/post/141346dd-7e1b-408d-b024-6756ce383480/image.png)

일반적인 Tree는 평균적으로 탐색에 대한 시간 복잡도로 O(logN)을 가진다.

그러나 이것은 평균적인 시간복잡도이며, 최악의 경우에는

![](https://velog.velcdn.com/images/sujipark2009/post/4854d833-1d09-44a8-b06e-e78e0f62e218/image.png)

이런식으로 한쪽으로 skewed 된 트리의 경우, 최악의 경우 시간복잡도 O(N)이 된다.

이러한 경우를 방지하기 위해, 밸런스 트리(Balanced Tree)를 이용할 수 있다.

> 밸런스 트리(Balanced Tree)란?
> 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재 정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리이다.
> 항상 양쪽 자식의 밸런스를 유지하므로, 무조건 O(logN)의 시간 복잡도를 가지게 된다.
> 다만 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어지게 된다.
> 그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 볼 수 있다.
> 대표적으로 **ReadBlack-Tree,B-Tree** 가 있다.

데이터베이스의 인덱스는 밸런스 트리, 그 중 `B-Tree`를 선택했다.

그런데 왜 하필 B-Tree일까?

- 탐색 시간이 O(logN)인 자료구조나 알고리즘은 다른 것들도 많고, 특히 해시 테이블의 경우 O(1)인데 차라리 해시를 쓰는게 더 낫지않나?

- B-Tree말고 RedBlack-Tree로도 사용할 수 있는거 아닌가?

이제 알아보자.

**탐색시간이 제일 빠른 해시 테이블을 DB 인덱스로 사용할 수 없는 이유**

![](https://velog.velcdn.com/images/sujipark2009/post/e59caca3-c93f-48f2-9cbc-dfafcef07b4c/image.png)

모든 자료구조와 그 어떤 알고리즘을 비교해도 탐색 시간이 가장 빠른 것은 해시테이블이다.
해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 O(1) 이라는 시간 복잡도를 가진다.

그러나 이는 온전히 `단 하나의 데이터를 탐색하는 시간` 에만 O(1) 이다.
예를 들어 1,2,3,4,5가 저장되어 있는 해시 테이블에서 3이라는 데이터를 찾을 때에만 O(1) 이라는 것이다.

그게 무엇이 문제냐면, **우리는 DB에서 등호(=) 뿐만 아니라 부등호(>,<)도 사용할 수 있다**는 것이 문제이다.

**모든 값이 정렬되어있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수 없다**.

그렇기에 기준 값보다 크거나 작은 요소들을 탐색할 수 있어야 하는 DB 인덱스의 용도로 해시 테이블은 어울리지 않는 자료구조인 것이다.

**OK 그럼 탐색이 O(logN)인 다른 자료구조나 알고리즘은 왜 못쓰는걸까?**

RedBlack Tree와 B-Tree의 특징을 비교해보자.

**RedBlack-Tree의 특징**

![](https://velog.velcdn.com/images/sujipark2009/post/2bcc3148-838c-4eba-9cf6-81f93b75d27e/image.png)

각 노드는 하나의 값만 가진 상태로, 좌,우 자식 노드의 개수 밸런스를 맞춘다.
빨간색, 검은색 노드로 구분되어 있는 것은 노드의 삽입/삭제 작업을 할 때마다 규칙에 맞게 재정렬을 하기 위한 수단이므로 크게 신경 쓰지 않아도 된다.

**B-Tree의 특징**

![](https://velog.velcdn.com/images/sujipark2009/post/f6c59c73-4302-4d4e-a36f-80c5b8ebbbc8/image.png)

B-Tree는 위처럼 노드 하나에 여러 데이터가 저장될 수 있다. 각 노드 내 데이터들은 항상 정렬된 상태이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다.
그러므로 자식 노드 개수는 (N+1)을 가진다.

이처럼, 위 두 개의 트리는 항상 좌,우 자식노드 개수의 밸런스를 유지하므로 최악의 경우에도 무조건 탐색 시간이 O(logN)을 가지게 된다.

이것만 보면 B-Tree 뿐 아니라, RedBlack-Tree도 DB 인덱스로 사용하기에는 큰 문제가 없어 보인다.
그러면 도대체 왜 RedBlack-Tree는 DB 인덱스로 사용되지 않는걸까?

위의 사진만 봐도 알 수 있듯이, 이 둘의 가장 큰 차이는 `하나의 노드가 가지는 데이터 개수` 이다.
RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만을, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장한다.

![](https://velog.velcdn.com/images/sujipark2009/post/fecf5f8d-408d-40d7-8ef8-91c9a8a9a83f/image.png)

표시한 부분을 보면, 마치 배열처럼 정렬이 되어있다.
실제 메모리 상에 차례대로 저장이 되어있는 것이다. 같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 `참조 포인터` 값으로 접근할 필요가 없다.

이는 즉, 같은 노드 상 데이터를 탐색할 때는 포인터 접근을 하는 것이 아니라 **실제 메모리 디스크에서 바로 다음 인덱스의 접근을 하는 것**이다.

다시 RedBlack-Tree를 보면,

![](https://velog.velcdn.com/images/sujipark2009/post/3921f588-2646-41e0-8abb-b8491203fcef/image.png)

RedBlack-Tree는 B-Tree와 다르게 각 노드마다 무조건 하나의 데이터만 가지게 되므로 모든 데이터를 접근할 때 무조건 참조 포인터로 접근을 하게 된다. 따라서 **B-Tree의 배열 형식의 접근과 RedBlack-Tree의 참조 포인터 접근의 시간차이**를 알아야 한다.

사실 둘 다 시간 복잡도는 O(logN)이라는 것은 변함이 없다.
그러나 이러한 시간 복잡도는 알고리즘 처리에 대한 이론적인 시간 계산 방식일 뿐이다. 물리적, 절대적인 시간 개념으로는 배열 접근이 훨씬 빠를 수 밖에 없다.

참조 포인터로 메모리에 접근한다는 것은, 실제 메모리 상 순서대로 저장이 되었든 안 되었든 접근하려는 주소를 연산을 통해 직접 알아내어 데이터에 접근한다는 것이다.

주소를 알아내는데 CPU 내부적으로 연산을 수행하게 된다.

이와 반대로 배열은 데이터들이 메모리 공간에 차례대로 저장이 되어 있으므로, 접근할 주소를 바로 알 수 있다. 그래서 메모리 주소를 알아내는데 성능이 영향이 없다.
비록 B-Tree도 자식 노드를 접근할 땐 참조 포인터로 접근을 하지만, 하나의 노드가 가지는 데이터 개수가 많아질수록 포인터 개수는 확연히 줄어들고, 트리 내에서 다루는 데이터가 많아질수록 이러한 차이는 더욱 커질 것이다.

비록 같은 O(logN)이지만, 포인터 접근 수의 차이로 인해 B-Tree가 RedBlack-Tree보다 탐색 시간이 더 빠를 수 밖에 없다.

**참조 포인터가 문제라면, 그냥 참조 요소 자체가 없는 배열을 쓰면 되지않나?**

데이터 접근이 빠른 자료구조 `배열` 이 DB 인덱스로 선택받지 못한 이유는..

배열은 참조 포인터라는 개념이 없고, 모든 데이터가 메모리 상 차례대로 저장되어 있어 접근이 매우 빠르다.
참조가 없으니 탐색 속도로만 본다면 B-Tree보다 훨씬 빠르다. 뿐만 아니라, 해시 테이블과는 다르게 데이터들을 정렬 상태로 유지할 수 있으므로 부등호 연산에도 문제가 없다.

하지만 배열이 `B-Tree보다 빠른 것은 탐색`뿐 이다.

배열 내에서 데이터 저장,삭제가 일어나는 순간 B-Tree보다 훨씬 비효율적인 성능이 발생하게 된다.

그래서.. 모든 면으로 DB인덱스 용도로 가장 적합한 자료구조는 B-Tree가 되었다고 한다..

**해시 인덱스**

- 데이터를 해시로 계산하여 키-값 쌍으로 저장

**장점**

- 특정 값을 찾는 검색 속도가 매우 빠름

**단점**

- 범위 검색과 순차 검색이 느림
- 충돌 발생 시 성능 저하 가능
- 정렬된 데이터 다루기 어려움

**사용**

키-값 조회가 많은 시스템 - NoSQL

**비트맵 인덱스**

- 각 열 값에 대해 비트 배열을 사용하여 데이터 존재 여부를 표현

- 읽기 성능이 매우 뛰어남
  읽기 전용 또는 읽기가 많은 환경에서 아용

- 공간 효율성이 높음
  데이터가 희소하거나 이산형 값일 때

**장점**

- 다중 열의 검색 조건(AND,OR)을 빠르게 처리

**단점**

- 데이터가 자주 변경되는 테이블에서는 비효율적

**Full-Text Index**

- 텍스트 데이터를 효율적으로 검색하기 위한 인덱스

**특징**

- 텍스트 필드에서 특정 키워드 빠르게 검색
- 단어 분리, 정규화와 같은 작업 포함
- 검색 엔진, 텍스트 기반 DB

#### Table Full Scan과 Index Range Scan을 설명해 주세요

---

**Table Full Scan**

- 테이블의 모든 행을 순차적으로 스캔하여 검색
- 인덱스를 사용하지 않고 검색하는 경우

**Index Range Scan**

- 인덱스를 사용하여 테이블의 일부 데이터만 검색

- 인덱스 구조를 탐색하여 검색 범위의 시작 지점을 찾음
- 인덱스를 따라 범위에 해당하는 값만 검색
- 포인터를 따라서 데이터 가져옴

- 범위 검색과 특정 조건 검색에 유리

#### 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

---

- 쿼리 옵티마이저의 판단

쿼리 실행 전 다양한 실행 계획 평가 - Full Scan이 효율적이면 그것을 수행

- 데이터 양과 선택도

쿼리 조건에 따라 반환되는 데이터의 비율

높으면 - 인덱스 사용 유리
낮으면 - Full Scan이 유리

- 인덱스 조건 불일치

인덱스 활용 불가능한 조건이 포함된 경우

**예시**

- 함수 사용

SELECT \* FROM users WHERE upper(name) = 'ALICE';

스트링이 변환되기 때문

함수 기반 인덱스로 해결 가능

- 연산 포함

SELECT _ FROM orders WHERE total_price _ 1.1 > 1000;

WHERE 절에 연산이 포함되면 인덱스 사용 불가

- 인덱스가 커버링 되지 않음

커버링 인덱스 - 쿼리에 필요한 모든 열이 인덱스에 포함된 경우

SELECT name,email FROM users WHERE age = 25;
age는 인덱싱이 되지만, name,email은 없음 -> 테이블 추가 접근 필요

이는 복합 인덱스를 생성하여 해결이 가능하다

- 테이블이 너무 작음

테이블이 작으면 Full Scan이 효율적일 수 있음

#### Order By/Group By 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.

---

- 인덱스 존재

이미 정렬된 상태

- 인덱스 없음

1차적으로 메모리에서 정렬이 수행

메모리 크기보다 큰 작업이 요구된다면 디스크 I/O 가 추가적으로 발생

#### 일반적으로 인덱스는 수정이 잦은 테이블에서 사용하지 않기를 권합니다. 이유가 무엇일까요?

---

**Index의 단점**

- DML의 효율이 떨어짐.

인덱스 관리에 DB의 10%에 해당하는 저장공간이 추가로 필요

DML보다 검색이 빈번한 테이블에 인덱스를 생성해야 함

- INSERT,UPDATE,DELETE를 통해 데이터가 추가되거나 값이 바뀌는 경우

인덱스 테이블 내에 있는 값들을 다시 정렬해야 함

인덱스 테이블, 원본 테이블 두 군데의 데이터 수정 작업이 필요

**결론**

인덱스를 추가로 생성하는 행위는, 하나의 쿼리를 빠르게 하지만 전체 성능 부하를 초래한다.

인덱스 생성보다는 SQL문을 조금 더 효율적으로 짜야한다.

#### 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?

---

- 기본키와 인덱스는 서로 다른 개념이지만, 기본키는 암묵적으로 인덱스 역할을 할 수 있음

기본키로 설정된 열은, 암묵적으로 인덱스가 생성됨

기본키를 통해 모든 레코드를 구분할 수 있기 때문이다.

- 모든 인덱스가 기본키인 것은 아님

인덱스가 된 열의 값이 고유하지 않을 수도 있다.

NULL 값을 허용할 수도 있다

한 테이블에 여러 개의 인덱스를 가질 수도 있다.

#### 그렇다면 외래키는요?

---

- 외래키를 인덱스로 설정할 수 있음

JOIN 연산을 자주 수행하는 경우, 외래키를 인덱스로 설정하면 일반적으로 성능이 좋아짐

외래키가 인덱스로 설정되지 않으면, JOIN시에 전체 테이블 스캔을 수행해야 함

### 데이터베이스 성능 및 관리

---

#### 디스크 구조를 설명해주세요.

---

![](https://velog.velcdn.com/images/sujipark2009/post/284722d7-a0cc-4fe6-a5e5-c22000dc72d1/image.png)

**물리적 구조**

- 트랙

디스크 표면에서 동심원 형태로 데이터를 저장하는 원형 경로

디스크는 회전하면서 데이터를 씀. 트랙 = 원형의 길

가장 바깥쪽 원에서 안쪽 원까지 셈

- 섹터

트랙을 호의 형태로 나눈 부분

보통 512~4096B. 각 세터는 고정 크기의 데이터 저장

트랙이 나눠진 최소 단위

0도 기준으로 시계 방향으로 번호를 매김

- 블록

파일 시스템에서 사용하는 여러 섹터를 묶은 논리적 단위

보통 4,8,16KB. 파일 시스템에 따라 크기가 다름

디스크는 블록 단위로 읽고 쓰는 작업을 한다.

#### 디스크에서 데이터를 읽어오는 과정을 설명해주세요.

---

**요약**

- 논리적 요청(파일 또는 데이터)을 디스크의 물리적 구조로 변환하여 데이터를 검색하고 전달

**파일 시스템 요청**

사용자나 App이 요청하면 파일 시스템이 처리

요청된 데이터의 블록 주소를 확인

**논리적 주소 -> 물리적 주소**

디스크 컨트롤러가 LBA를 CHS로 변환

**LBA**

- Logical Block Address

파일 시스템의 논리적 주소

**CHS**

Cylinder-Head-Sector

디스크의 트랙,헤드,섹터 정보를 기반으로 데이터를 찾는 물리적 주소

**디스크 액세스 과정**

- 헤드 위치 결정

읽기/쓰기 헤드가 목적지인 트랙으로 이동
디스크가 회전하면서 원하는 트랙이 헤드 아래로 올 때까지 대기

- 섹터 위치 확인

헤드가 요청된 트랙으로 오면, 디스크가 계속 회전하여 요청된 섹터로 이동

섹터 번호를 기준으로 찾기

- 데이터 읽기

헤드가 데이터를 읽음 - 플래터의 자성 신호를 디지털 데이터로 변환

- 데이터 전송

데이터가 디스크 컨트롤러를 통해 메모리로 전송

**버퍼링 및 전달**

- 데이터가 디스크 내부 캐시 또는 버퍼에 저장

- 요청한 앱으로 전달

- 버퍼링은 디스크와 메모리 간의 속도 차이 완화

#### B-Tree와 B+ Tree에 대해 설명해 주세요.

---

**M-way Search Tree**

하나의 노드가 M개의 가지를 가질 수 있는 탐색 트리

이진 검색 트리의 확장

\**B Tree*8

각 노드에 여러 개의 키와 자식을 가지는 다진 탐색 트리

**특징**

- 균형 유지

루트 노드에서 리프 노드까지의 경로 길이가 동일(균등)

트리 높이를 최소화하여 성능 향상

- 노드 구조

키는 항상 오름차순, 각 노드에 최대 m-1개의 키와 m개의 자식

- 데이터 저장

내부 노드와 리프 노드 모두에 데이터 저장

- 성능

삽입,삭제,검색에 있어서 O(logN)

- 단점

데이터가 여러 노드에 분산되어 있어 범위 검색이 비효율적

내부 노드에도 데이터를 저장하여 디스크 I/O 증가

**B+ Tree**

- B-Tree를 확장하여 내부 노드와 리프 노드 역할이 분리

- B-Tree와의 차이

리프노드 - 데이터 저장은 리프 노드에만, 링크드 리스트 구조를 사용하여 범위 검색에 유리

내부 노드 - 데이터 없이 검색 인덱스 역할만

- 장점

범위 검색이 효율적, 데이터가 리프 노드에만 있어서 디스크 I/O가 감소

- 단점

검색 시 항상 리프노드까지 탐색해야 하므로, 단일 키 검색이 B-Tree보다 느릴 수 있음

#### 그렇다면 B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요?

---

B+Tree는 검색 시 항상 리프 노드까지 탐색해야 하므로 단일 키 검색이 B-Tree에 보다 느릴 수 있음

#### DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?

---

- B-Tree와 B+Tree의 가장 중요한 특징 중 하나는 디스크 I/O 작업을 최소화 하는데 중점을 두고 설계

- 장점

디스크 I/O 횟수 최소화

B 트리는 트리 높이가 낮음 -> 데이터를 검색할 때 필요한 디스크 접근 횟수를 줄임

RBT는 키와 노드가 1:1 이라 높이가 높음

대량 데이터 처리

B 트리는 대량의 키 저장 -> 각 노드의 크기를 디스크 블록 크기로 최적화 가능
RBT는 메모리 연산에 적합한 구조 -> 정렬 작업

범위 검색

- DB에서는 범위 검색이 빈번, B+트리는 범위 검색이 수월

RBT의 경우, 중위 순회가 필요

#### 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

---

B-Tree와 B+Tree는 일반적으로 오름차순으로 정렬된 인덱스를 저장하도록 설계되어 있음

- 내림차순

B+Tree -> 모든 리프노드가 연결 리스트로 연결되어 있어서, 이 연결 리스트를 역순으로 읽는 것으로 내림차순 정렬을 수행

트리의 모든 키를 한 번에 메모리에 저장할 수 없는 경우엔 적용이 불가능

- 오름차순으로 읽는 경우

B-Tree는 중위순회를 해야 함 -> Disk I/O가 많이 발생 O(N)

B+Tree는 연결 리스트 따라가기 -> O(logM) + O(N) , Disk I/O 최소화

#### 트래픽이 높아질 때 DB는 어떻게 관리를 할 수 있을까요?

---

**스케일링**

- 수직 스케일링

하드웨어(CPU/RAM)을 업그레이드 하여 서버의 성능을 향상시키는 방법

트래픽 증가에 따라 더 많은 요청을 처리하는데 도움

- 수평 스케일링

추가 서버를 도입하여 요청을 분산시키는 방법

로드 밸런서를 사용하여 요청을 여러 서버에 분산시키는 방식

데이터베이스 시스템의 용량을 증가시키는 데 효과적

**샤딩**

- 데이터베이스를 여러 부분(샤드)으로 나누는 방법
- 각 샤드는 독립적으로 운영
- 서로 다른 서버에서 호스팅 될 수 있음

**캐싱**

- 자주 사용되는 데이터를 빠르게 접근 가능한 저장소에 저장하는 기술
- 데이터베이스 서버의 부하를 줄이고, 응답 시간을 개선
- Redis나 Memcached와 같은 인메모리 데이터베이스 시스템

**인덱싱**

- 데이터베이스에서 특정 데이터를 빠르게 찾을 수 있도록 인덱스를 사용
- 쿼리 성능을 크게 향상

**쿼리 최적화**

- 쿼리를 최적화하여 실행 시간을 줄이는 것
- 쿼리 분석 및 수정, 불필요한 쿼리 제거, 복잡한 쿼리의 분해

#### DB의 Connection Pool에 대해 설명해 주세요

---

- 성능 최적화를 위한 기법 중 하나

데이터베이스 연결을 재사용할 수 있도록 관리하는 일종의 캐시

데이터베이스에 연결하고 연결을 닫는데 드는 비용을 줄임

**동작 원리**

- 일련의 DB연결을 생성하고 이들을 풀에 저장
- Application이 DB연결을 요청하면, 풀은 사용 가능한 연결 중 하나를 제공
  이 연결은 풀에서 "체크아웃" 되어 사용중으로 표시

- Application이 DB작업을 완료하면, 연결을 닫는 대신 풀로 다시 "체크인"
  이렇게 되면 연결은 다시 사용 가능 상태가 된다

- 연결 풀은 일정 시간 동안 사용되지 않은 연결을 선택적으로 닫을 수 있음 -> 시스템 리소스 절약 가능

**장점**

- DB연결의 재사용

연결을 매번 새로 생성하는 것은 리소스를 많이 소모
연결 풀을 사용하면 이러한 비용을 줄일 수 있음

- 연결 수 제한

DB 서버는 동시에 처리할 수 있는 연결 수에 제한

연결 풀을 사용하면 동시 연결 수를 제한하고 관리

- 연결 대기 시간 감소

연결 풀에서 바로 사용가능한 연결을 가져올 수 있으므로 연결을 생성하고 닫는 데 걸리는 시간을 절약

#### DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

---

- 연결 요청

클라이언트는 DB에 연결을 요청.
DB의 IP 주소 또는 호스트 이름, 포트 번호, 사용자 이름과 패스워드 같은 인증 정보를 포함

- 연결 승인

DB는 이 요청을 받아들이고 인증을 확인

인증 정보가 유효하다면, DB는 연결을 수락하고 클라이언트에게 알림

- 세션 생성

연결이 수락되면, DB는 해당 클라이언트에 대해 세션을 생성

세션은 클라이언트와 DB 사이의 통신 상태를 나타냄. 각 세션은 고유한 세션 ID를 가짐

- 쿼리 전송 및 수행

클라이언트는 이제 DB에 쿼리를 보낼 수 있음.
DB는 이 쿼리를 수행하고 결과를 클라이언트에게 반환

- 연결 종료

클라이언트가 더 이상 DB서비스가 필요하지 않을 때, 클라이언트는 연결을 종료하거나 닫을 수 있음

DB는 해당 세션을 종료하고 사용한 리소스를 회수
